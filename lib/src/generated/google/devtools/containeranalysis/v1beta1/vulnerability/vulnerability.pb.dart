//
//  Generated code. Do not modify.
//  source: google/devtools/containeranalysis/v1beta1/vulnerability/vulnerability.proto
//
// @dart = 2.12

// ignore_for_file: annotate_overrides, camel_case_types, comment_references
// ignore_for_file: constant_identifier_names, library_prefixes
// ignore_for_file: non_constant_identifier_names, prefer_final_fields
// ignore_for_file: unnecessary_import, unnecessary_this, unused_import

import 'dart:core' as $core;

import 'package:protobuf/protobuf.dart' as $pb;

import '../../../../protobuf/timestamp.pb.dart' as $1;
import '../common/common.pb.dart' as $3;
import '../cvss/cvss.pb.dart' as $0;
import '../package/package.pb.dart' as $2;
import 'vulnerability.pbenum.dart';

export 'vulnerability.pbenum.dart';

/// Identifies all appearances of this vulnerability in the package for a
/// specific distro/location. For example: glibc in
/// cpe:/o:debian:debian_linux:8 for versions 2.1 - 2.2
class Vulnerability_Detail extends $pb.GeneratedMessage {
  factory Vulnerability_Detail({
    $core.String? cpeUri,
    $core.String? package,
    $2.Version? minAffectedVersion,
    $2.Version? maxAffectedVersion,
    $core.String? severityName,
    $core.String? description,
    VulnerabilityLocation? fixedLocation,
    $core.String? packageType,
    $core.bool? isObsolete,
    $1.Timestamp? sourceUpdateTime,
  }) {
    final $result = create();
    if (cpeUri != null) {
      $result.cpeUri = cpeUri;
    }
    if (package != null) {
      $result.package = package;
    }
    if (minAffectedVersion != null) {
      $result.minAffectedVersion = minAffectedVersion;
    }
    if (maxAffectedVersion != null) {
      $result.maxAffectedVersion = maxAffectedVersion;
    }
    if (severityName != null) {
      $result.severityName = severityName;
    }
    if (description != null) {
      $result.description = description;
    }
    if (fixedLocation != null) {
      $result.fixedLocation = fixedLocation;
    }
    if (packageType != null) {
      $result.packageType = packageType;
    }
    if (isObsolete != null) {
      $result.isObsolete = isObsolete;
    }
    if (sourceUpdateTime != null) {
      $result.sourceUpdateTime = sourceUpdateTime;
    }
    return $result;
  }
  Vulnerability_Detail._() : super();
  factory Vulnerability_Detail.fromBuffer($core.List<$core.int> i,
          [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) =>
      create()..mergeFromBuffer(i, r);
  factory Vulnerability_Detail.fromJson($core.String i,
          [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) =>
      create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(
      _omitMessageNames ? '' : 'Vulnerability.Detail',
      package: const $pb.PackageName(
          _omitMessageNames ? '' : 'grafeas.v1beta1.vulnerability'),
      createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'cpeUri')
    ..aOS(2, _omitFieldNames ? '' : 'package')
    ..aOM<$2.Version>(3, _omitFieldNames ? '' : 'minAffectedVersion',
        subBuilder: $2.Version.create)
    ..aOM<$2.Version>(4, _omitFieldNames ? '' : 'maxAffectedVersion',
        subBuilder: $2.Version.create)
    ..aOS(5, _omitFieldNames ? '' : 'severityName')
    ..aOS(6, _omitFieldNames ? '' : 'description')
    ..aOM<VulnerabilityLocation>(7, _omitFieldNames ? '' : 'fixedLocation',
        subBuilder: VulnerabilityLocation.create)
    ..aOS(8, _omitFieldNames ? '' : 'packageType')
    ..aOB(9, _omitFieldNames ? '' : 'isObsolete')
    ..aOM<$1.Timestamp>(10, _omitFieldNames ? '' : 'sourceUpdateTime',
        subBuilder: $1.Timestamp.create)
    ..hasRequiredFields = false;

  @$core.Deprecated('Using this can add significant overhead to your binary. '
      'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
      'Will be removed in next major version')
  Vulnerability_Detail clone() =>
      Vulnerability_Detail()..mergeFromMessage(this);
  @$core.Deprecated('Using this can add significant overhead to your binary. '
      'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
      'Will be removed in next major version')
  Vulnerability_Detail copyWith(void Function(Vulnerability_Detail) updates) =>
      super.copyWith((message) => updates(message as Vulnerability_Detail))
          as Vulnerability_Detail;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static Vulnerability_Detail create() => Vulnerability_Detail._();
  Vulnerability_Detail createEmptyInstance() => create();
  static $pb.PbList<Vulnerability_Detail> createRepeated() =>
      $pb.PbList<Vulnerability_Detail>();
  @$core.pragma('dart2js:noInline')
  static Vulnerability_Detail getDefault() => _defaultInstance ??=
      $pb.GeneratedMessage.$_defaultFor<Vulnerability_Detail>(create);
  static Vulnerability_Detail? _defaultInstance;

  /// Required. The CPE URI in
  /// [cpe format](https://cpe.mitre.org/specification/) in which the
  /// vulnerability manifests. Examples include distro or storage location for
  /// vulnerable jar.
  @$pb.TagNumber(1)
  $core.String get cpeUri => $_getSZ(0);
  @$pb.TagNumber(1)
  set cpeUri($core.String v) {
    $_setString(0, v);
  }

  @$pb.TagNumber(1)
  $core.bool hasCpeUri() => $_has(0);
  @$pb.TagNumber(1)
  void clearCpeUri() => clearField(1);

  /// Required. The name of the package where the vulnerability was found.
  @$pb.TagNumber(2)
  $core.String get package => $_getSZ(1);
  @$pb.TagNumber(2)
  set package($core.String v) {
    $_setString(1, v);
  }

  @$pb.TagNumber(2)
  $core.bool hasPackage() => $_has(1);
  @$pb.TagNumber(2)
  void clearPackage() => clearField(2);

  /// The min version of the package in which the vulnerability exists.
  @$pb.TagNumber(3)
  $2.Version get minAffectedVersion => $_getN(2);
  @$pb.TagNumber(3)
  set minAffectedVersion($2.Version v) {
    setField(3, v);
  }

  @$pb.TagNumber(3)
  $core.bool hasMinAffectedVersion() => $_has(2);
  @$pb.TagNumber(3)
  void clearMinAffectedVersion() => clearField(3);
  @$pb.TagNumber(3)
  $2.Version ensureMinAffectedVersion() => $_ensure(2);

  /// The max version of the package in which the vulnerability exists.
  @$pb.TagNumber(4)
  $2.Version get maxAffectedVersion => $_getN(3);
  @$pb.TagNumber(4)
  set maxAffectedVersion($2.Version v) {
    setField(4, v);
  }

  @$pb.TagNumber(4)
  $core.bool hasMaxAffectedVersion() => $_has(3);
  @$pb.TagNumber(4)
  void clearMaxAffectedVersion() => clearField(4);
  @$pb.TagNumber(4)
  $2.Version ensureMaxAffectedVersion() => $_ensure(3);

  /// The severity (eg: distro assigned severity) for this vulnerability.
  @$pb.TagNumber(5)
  $core.String get severityName => $_getSZ(4);
  @$pb.TagNumber(5)
  set severityName($core.String v) {
    $_setString(4, v);
  }

  @$pb.TagNumber(5)
  $core.bool hasSeverityName() => $_has(4);
  @$pb.TagNumber(5)
  void clearSeverityName() => clearField(5);

  /// A vendor-specific description of this note.
  @$pb.TagNumber(6)
  $core.String get description => $_getSZ(5);
  @$pb.TagNumber(6)
  set description($core.String v) {
    $_setString(5, v);
  }

  @$pb.TagNumber(6)
  $core.bool hasDescription() => $_has(5);
  @$pb.TagNumber(6)
  void clearDescription() => clearField(6);

  /// The fix for this specific package version.
  @$pb.TagNumber(7)
  VulnerabilityLocation get fixedLocation => $_getN(6);
  @$pb.TagNumber(7)
  set fixedLocation(VulnerabilityLocation v) {
    setField(7, v);
  }

  @$pb.TagNumber(7)
  $core.bool hasFixedLocation() => $_has(6);
  @$pb.TagNumber(7)
  void clearFixedLocation() => clearField(7);
  @$pb.TagNumber(7)
  VulnerabilityLocation ensureFixedLocation() => $_ensure(6);

  /// The type of package; whether native or non native(ruby gems, node.js
  /// packages etc).
  @$pb.TagNumber(8)
  $core.String get packageType => $_getSZ(7);
  @$pb.TagNumber(8)
  set packageType($core.String v) {
    $_setString(7, v);
  }

  @$pb.TagNumber(8)
  $core.bool hasPackageType() => $_has(7);
  @$pb.TagNumber(8)
  void clearPackageType() => clearField(8);

  /// Whether this detail is obsolete. Occurrences are expected not to point to
  /// obsolete details.
  @$pb.TagNumber(9)
  $core.bool get isObsolete => $_getBF(8);
  @$pb.TagNumber(9)
  set isObsolete($core.bool v) {
    $_setBool(8, v);
  }

  @$pb.TagNumber(9)
  $core.bool hasIsObsolete() => $_has(8);
  @$pb.TagNumber(9)
  void clearIsObsolete() => clearField(9);

  /// The time this information was last changed at the source. This is an
  /// upstream timestamp from the underlying information source - e.g. Ubuntu
  /// security tracker.
  @$pb.TagNumber(10)
  $1.Timestamp get sourceUpdateTime => $_getN(9);
  @$pb.TagNumber(10)
  set sourceUpdateTime($1.Timestamp v) {
    setField(10, v);
  }

  @$pb.TagNumber(10)
  $core.bool hasSourceUpdateTime() => $_has(9);
  @$pb.TagNumber(10)
  void clearSourceUpdateTime() => clearField(10);
  @$pb.TagNumber(10)
  $1.Timestamp ensureSourceUpdateTime() => $_ensure(9);
}

class Vulnerability_WindowsDetail_KnowledgeBase extends $pb.GeneratedMessage {
  factory Vulnerability_WindowsDetail_KnowledgeBase({
    $core.String? name,
    $core.String? url,
  }) {
    final $result = create();
    if (name != null) {
      $result.name = name;
    }
    if (url != null) {
      $result.url = url;
    }
    return $result;
  }
  Vulnerability_WindowsDetail_KnowledgeBase._() : super();
  factory Vulnerability_WindowsDetail_KnowledgeBase.fromBuffer(
          $core.List<$core.int> i,
          [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) =>
      create()..mergeFromBuffer(i, r);
  factory Vulnerability_WindowsDetail_KnowledgeBase.fromJson($core.String i,
          [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) =>
      create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(
      _omitMessageNames ? '' : 'Vulnerability.WindowsDetail.KnowledgeBase',
      package: const $pb.PackageName(
          _omitMessageNames ? '' : 'grafeas.v1beta1.vulnerability'),
      createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'name')
    ..aOS(2, _omitFieldNames ? '' : 'url')
    ..hasRequiredFields = false;

  @$core.Deprecated('Using this can add significant overhead to your binary. '
      'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
      'Will be removed in next major version')
  Vulnerability_WindowsDetail_KnowledgeBase clone() =>
      Vulnerability_WindowsDetail_KnowledgeBase()..mergeFromMessage(this);
  @$core.Deprecated('Using this can add significant overhead to your binary. '
      'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
      'Will be removed in next major version')
  Vulnerability_WindowsDetail_KnowledgeBase copyWith(
          void Function(Vulnerability_WindowsDetail_KnowledgeBase) updates) =>
      super.copyWith((message) =>
              updates(message as Vulnerability_WindowsDetail_KnowledgeBase))
          as Vulnerability_WindowsDetail_KnowledgeBase;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static Vulnerability_WindowsDetail_KnowledgeBase create() =>
      Vulnerability_WindowsDetail_KnowledgeBase._();
  Vulnerability_WindowsDetail_KnowledgeBase createEmptyInstance() => create();
  static $pb.PbList<Vulnerability_WindowsDetail_KnowledgeBase>
      createRepeated() =>
          $pb.PbList<Vulnerability_WindowsDetail_KnowledgeBase>();
  @$core.pragma('dart2js:noInline')
  static Vulnerability_WindowsDetail_KnowledgeBase getDefault() =>
      _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<
          Vulnerability_WindowsDetail_KnowledgeBase>(create);
  static Vulnerability_WindowsDetail_KnowledgeBase? _defaultInstance;

  /// The KB name (generally of the form KB[0-9]+ i.e. KB123456).
  @$pb.TagNumber(1)
  $core.String get name => $_getSZ(0);
  @$pb.TagNumber(1)
  set name($core.String v) {
    $_setString(0, v);
  }

  @$pb.TagNumber(1)
  $core.bool hasName() => $_has(0);
  @$pb.TagNumber(1)
  void clearName() => clearField(1);

  /// A link to the KB in the Windows update catalog -
  /// https://www.catalog.update.microsoft.com/
  @$pb.TagNumber(2)
  $core.String get url => $_getSZ(1);
  @$pb.TagNumber(2)
  set url($core.String v) {
    $_setString(1, v);
  }

  @$pb.TagNumber(2)
  $core.bool hasUrl() => $_has(1);
  @$pb.TagNumber(2)
  void clearUrl() => clearField(2);
}

class Vulnerability_WindowsDetail extends $pb.GeneratedMessage {
  factory Vulnerability_WindowsDetail({
    $core.String? cpeUri,
    $core.String? name,
    $core.String? description,
    $core.Iterable<Vulnerability_WindowsDetail_KnowledgeBase>? fixingKbs,
  }) {
    final $result = create();
    if (cpeUri != null) {
      $result.cpeUri = cpeUri;
    }
    if (name != null) {
      $result.name = name;
    }
    if (description != null) {
      $result.description = description;
    }
    if (fixingKbs != null) {
      $result.fixingKbs.addAll(fixingKbs);
    }
    return $result;
  }
  Vulnerability_WindowsDetail._() : super();
  factory Vulnerability_WindowsDetail.fromBuffer($core.List<$core.int> i,
          [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) =>
      create()..mergeFromBuffer(i, r);
  factory Vulnerability_WindowsDetail.fromJson($core.String i,
          [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) =>
      create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(
      _omitMessageNames ? '' : 'Vulnerability.WindowsDetail',
      package: const $pb.PackageName(
          _omitMessageNames ? '' : 'grafeas.v1beta1.vulnerability'),
      createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'cpeUri')
    ..aOS(2, _omitFieldNames ? '' : 'name')
    ..aOS(3, _omitFieldNames ? '' : 'description')
    ..pc<Vulnerability_WindowsDetail_KnowledgeBase>(
        4, _omitFieldNames ? '' : 'fixingKbs', $pb.PbFieldType.PM,
        subBuilder: Vulnerability_WindowsDetail_KnowledgeBase.create)
    ..hasRequiredFields = false;

  @$core.Deprecated('Using this can add significant overhead to your binary. '
      'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
      'Will be removed in next major version')
  Vulnerability_WindowsDetail clone() =>
      Vulnerability_WindowsDetail()..mergeFromMessage(this);
  @$core.Deprecated('Using this can add significant overhead to your binary. '
      'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
      'Will be removed in next major version')
  Vulnerability_WindowsDetail copyWith(
          void Function(Vulnerability_WindowsDetail) updates) =>
      super.copyWith(
              (message) => updates(message as Vulnerability_WindowsDetail))
          as Vulnerability_WindowsDetail;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static Vulnerability_WindowsDetail create() =>
      Vulnerability_WindowsDetail._();
  Vulnerability_WindowsDetail createEmptyInstance() => create();
  static $pb.PbList<Vulnerability_WindowsDetail> createRepeated() =>
      $pb.PbList<Vulnerability_WindowsDetail>();
  @$core.pragma('dart2js:noInline')
  static Vulnerability_WindowsDetail getDefault() => _defaultInstance ??=
      $pb.GeneratedMessage.$_defaultFor<Vulnerability_WindowsDetail>(create);
  static Vulnerability_WindowsDetail? _defaultInstance;

  /// Required. The CPE URI in
  /// [cpe format](https://cpe.mitre.org/specification/) in which the
  /// vulnerability manifests. Examples include distro or storage location for
  /// vulnerable jar.
  @$pb.TagNumber(1)
  $core.String get cpeUri => $_getSZ(0);
  @$pb.TagNumber(1)
  set cpeUri($core.String v) {
    $_setString(0, v);
  }

  @$pb.TagNumber(1)
  $core.bool hasCpeUri() => $_has(0);
  @$pb.TagNumber(1)
  void clearCpeUri() => clearField(1);

  /// Required. The name of the vulnerability.
  @$pb.TagNumber(2)
  $core.String get name => $_getSZ(1);
  @$pb.TagNumber(2)
  set name($core.String v) {
    $_setString(1, v);
  }

  @$pb.TagNumber(2)
  $core.bool hasName() => $_has(1);
  @$pb.TagNumber(2)
  void clearName() => clearField(2);

  /// The description of the vulnerability.
  @$pb.TagNumber(3)
  $core.String get description => $_getSZ(2);
  @$pb.TagNumber(3)
  set description($core.String v) {
    $_setString(2, v);
  }

  @$pb.TagNumber(3)
  $core.bool hasDescription() => $_has(2);
  @$pb.TagNumber(3)
  void clearDescription() => clearField(3);

  /// Required. The names of the KBs which have hotfixes to mitigate this
  /// vulnerability. Note that there may be multiple hotfixes (and thus
  /// multiple KBs) that mitigate a given vulnerability. Currently any listed
  /// kb's presence is considered a fix.
  @$pb.TagNumber(4)
  $core.List<Vulnerability_WindowsDetail_KnowledgeBase> get fixingKbs =>
      $_getList(3);
}

/// Vulnerability provides metadata about a security vulnerability in a Note.
class Vulnerability extends $pb.GeneratedMessage {
  factory Vulnerability({
    $core.double? cvssScore,
    Severity? severity,
    $core.Iterable<Vulnerability_Detail>? details,
    $0.CVSSv3? cvssV3,
    $core.Iterable<Vulnerability_WindowsDetail>? windowsDetails,
    $1.Timestamp? sourceUpdateTime,
  }) {
    final $result = create();
    if (cvssScore != null) {
      $result.cvssScore = cvssScore;
    }
    if (severity != null) {
      $result.severity = severity;
    }
    if (details != null) {
      $result.details.addAll(details);
    }
    if (cvssV3 != null) {
      $result.cvssV3 = cvssV3;
    }
    if (windowsDetails != null) {
      $result.windowsDetails.addAll(windowsDetails);
    }
    if (sourceUpdateTime != null) {
      $result.sourceUpdateTime = sourceUpdateTime;
    }
    return $result;
  }
  Vulnerability._() : super();
  factory Vulnerability.fromBuffer($core.List<$core.int> i,
          [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) =>
      create()..mergeFromBuffer(i, r);
  factory Vulnerability.fromJson($core.String i,
          [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) =>
      create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(
      _omitMessageNames ? '' : 'Vulnerability',
      package: const $pb.PackageName(
          _omitMessageNames ? '' : 'grafeas.v1beta1.vulnerability'),
      createEmptyInstance: create)
    ..a<$core.double>(1, _omitFieldNames ? '' : 'cvssScore', $pb.PbFieldType.OF)
    ..e<Severity>(2, _omitFieldNames ? '' : 'severity', $pb.PbFieldType.OE,
        defaultOrMaker: Severity.SEVERITY_UNSPECIFIED,
        valueOf: Severity.valueOf,
        enumValues: Severity.values)
    ..pc<Vulnerability_Detail>(
        3, _omitFieldNames ? '' : 'details', $pb.PbFieldType.PM,
        subBuilder: Vulnerability_Detail.create)
    ..aOM<$0.CVSSv3>(4, _omitFieldNames ? '' : 'cvssV3',
        subBuilder: $0.CVSSv3.create)
    ..pc<Vulnerability_WindowsDetail>(
        5, _omitFieldNames ? '' : 'windowsDetails', $pb.PbFieldType.PM,
        subBuilder: Vulnerability_WindowsDetail.create)
    ..aOM<$1.Timestamp>(6, _omitFieldNames ? '' : 'sourceUpdateTime',
        subBuilder: $1.Timestamp.create)
    ..hasRequiredFields = false;

  @$core.Deprecated('Using this can add significant overhead to your binary. '
      'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
      'Will be removed in next major version')
  Vulnerability clone() => Vulnerability()..mergeFromMessage(this);
  @$core.Deprecated('Using this can add significant overhead to your binary. '
      'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
      'Will be removed in next major version')
  Vulnerability copyWith(void Function(Vulnerability) updates) =>
      super.copyWith((message) => updates(message as Vulnerability))
          as Vulnerability;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static Vulnerability create() => Vulnerability._();
  Vulnerability createEmptyInstance() => create();
  static $pb.PbList<Vulnerability> createRepeated() =>
      $pb.PbList<Vulnerability>();
  @$core.pragma('dart2js:noInline')
  static Vulnerability getDefault() => _defaultInstance ??=
      $pb.GeneratedMessage.$_defaultFor<Vulnerability>(create);
  static Vulnerability? _defaultInstance;

  /// The CVSS score for this vulnerability.
  @$pb.TagNumber(1)
  $core.double get cvssScore => $_getN(0);
  @$pb.TagNumber(1)
  set cvssScore($core.double v) {
    $_setFloat(0, v);
  }

  @$pb.TagNumber(1)
  $core.bool hasCvssScore() => $_has(0);
  @$pb.TagNumber(1)
  void clearCvssScore() => clearField(1);

  /// Note provider assigned impact of the vulnerability.
  @$pb.TagNumber(2)
  Severity get severity => $_getN(1);
  @$pb.TagNumber(2)
  set severity(Severity v) {
    setField(2, v);
  }

  @$pb.TagNumber(2)
  $core.bool hasSeverity() => $_has(1);
  @$pb.TagNumber(2)
  void clearSeverity() => clearField(2);

  /// All information about the package to specifically identify this
  /// vulnerability. One entry per (version range and cpe_uri) the package
  /// vulnerability has manifested in.
  @$pb.TagNumber(3)
  $core.List<Vulnerability_Detail> get details => $_getList(2);

  /// The full description of the CVSSv3.
  @$pb.TagNumber(4)
  $0.CVSSv3 get cvssV3 => $_getN(3);
  @$pb.TagNumber(4)
  set cvssV3($0.CVSSv3 v) {
    setField(4, v);
  }

  @$pb.TagNumber(4)
  $core.bool hasCvssV3() => $_has(3);
  @$pb.TagNumber(4)
  void clearCvssV3() => clearField(4);
  @$pb.TagNumber(4)
  $0.CVSSv3 ensureCvssV3() => $_ensure(3);

  /// Windows details get their own format because the information format and
  /// model don't match a normal detail. Specifically Windows updates are done as
  /// patches, thus Windows vulnerabilities really are a missing package, rather
  /// than a package being at an incorrect version.
  @$pb.TagNumber(5)
  $core.List<Vulnerability_WindowsDetail> get windowsDetails => $_getList(4);

  /// The time this information was last changed at the source. This is an
  /// upstream timestamp from the underlying information source - e.g. Ubuntu
  /// security tracker.
  @$pb.TagNumber(6)
  $1.Timestamp get sourceUpdateTime => $_getN(5);
  @$pb.TagNumber(6)
  set sourceUpdateTime($1.Timestamp v) {
    setField(6, v);
  }

  @$pb.TagNumber(6)
  $core.bool hasSourceUpdateTime() => $_has(5);
  @$pb.TagNumber(6)
  void clearSourceUpdateTime() => clearField(6);
  @$pb.TagNumber(6)
  $1.Timestamp ensureSourceUpdateTime() => $_ensure(5);
}

/// Details of a vulnerability Occurrence.
class Details extends $pb.GeneratedMessage {
  factory Details({
    $core.String? type,
    Severity? severity,
    $core.double? cvssScore,
    $core.Iterable<PackageIssue>? packageIssue,
    $core.String? shortDescription,
    $core.String? longDescription,
    $core.Iterable<$3.RelatedUrl>? relatedUrls,
    Severity? effectiveSeverity,
  }) {
    final $result = create();
    if (type != null) {
      $result.type = type;
    }
    if (severity != null) {
      $result.severity = severity;
    }
    if (cvssScore != null) {
      $result.cvssScore = cvssScore;
    }
    if (packageIssue != null) {
      $result.packageIssue.addAll(packageIssue);
    }
    if (shortDescription != null) {
      $result.shortDescription = shortDescription;
    }
    if (longDescription != null) {
      $result.longDescription = longDescription;
    }
    if (relatedUrls != null) {
      $result.relatedUrls.addAll(relatedUrls);
    }
    if (effectiveSeverity != null) {
      $result.effectiveSeverity = effectiveSeverity;
    }
    return $result;
  }
  Details._() : super();
  factory Details.fromBuffer($core.List<$core.int> i,
          [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) =>
      create()..mergeFromBuffer(i, r);
  factory Details.fromJson($core.String i,
          [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) =>
      create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(
      _omitMessageNames ? '' : 'Details',
      package: const $pb.PackageName(
          _omitMessageNames ? '' : 'grafeas.v1beta1.vulnerability'),
      createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'type')
    ..e<Severity>(2, _omitFieldNames ? '' : 'severity', $pb.PbFieldType.OE,
        defaultOrMaker: Severity.SEVERITY_UNSPECIFIED,
        valueOf: Severity.valueOf,
        enumValues: Severity.values)
    ..a<$core.double>(3, _omitFieldNames ? '' : 'cvssScore', $pb.PbFieldType.OF)
    ..pc<PackageIssue>(
        4, _omitFieldNames ? '' : 'packageIssue', $pb.PbFieldType.PM,
        subBuilder: PackageIssue.create)
    ..aOS(5, _omitFieldNames ? '' : 'shortDescription')
    ..aOS(6, _omitFieldNames ? '' : 'longDescription')
    ..pc<$3.RelatedUrl>(
        7, _omitFieldNames ? '' : 'relatedUrls', $pb.PbFieldType.PM,
        subBuilder: $3.RelatedUrl.create)
    ..e<Severity>(
        8, _omitFieldNames ? '' : 'effectiveSeverity', $pb.PbFieldType.OE,
        defaultOrMaker: Severity.SEVERITY_UNSPECIFIED,
        valueOf: Severity.valueOf,
        enumValues: Severity.values)
    ..hasRequiredFields = false;

  @$core.Deprecated('Using this can add significant overhead to your binary. '
      'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
      'Will be removed in next major version')
  Details clone() => Details()..mergeFromMessage(this);
  @$core.Deprecated('Using this can add significant overhead to your binary. '
      'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
      'Will be removed in next major version')
  Details copyWith(void Function(Details) updates) =>
      super.copyWith((message) => updates(message as Details)) as Details;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static Details create() => Details._();
  Details createEmptyInstance() => create();
  static $pb.PbList<Details> createRepeated() => $pb.PbList<Details>();
  @$core.pragma('dart2js:noInline')
  static Details getDefault() =>
      _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<Details>(create);
  static Details? _defaultInstance;

  /// The type of package; whether native or non native(ruby gems, node.js
  /// packages etc)
  @$pb.TagNumber(1)
  $core.String get type => $_getSZ(0);
  @$pb.TagNumber(1)
  set type($core.String v) {
    $_setString(0, v);
  }

  @$pb.TagNumber(1)
  $core.bool hasType() => $_has(0);
  @$pb.TagNumber(1)
  void clearType() => clearField(1);

  /// Output only. The note provider assigned Severity of the vulnerability.
  @$pb.TagNumber(2)
  Severity get severity => $_getN(1);
  @$pb.TagNumber(2)
  set severity(Severity v) {
    setField(2, v);
  }

  @$pb.TagNumber(2)
  $core.bool hasSeverity() => $_has(1);
  @$pb.TagNumber(2)
  void clearSeverity() => clearField(2);

  /// Output only. The CVSS score of this vulnerability. CVSS score is on a
  /// scale of 0-10 where 0 indicates low severity and 10 indicates high
  /// severity.
  @$pb.TagNumber(3)
  $core.double get cvssScore => $_getN(2);
  @$pb.TagNumber(3)
  set cvssScore($core.double v) {
    $_setFloat(2, v);
  }

  @$pb.TagNumber(3)
  $core.bool hasCvssScore() => $_has(2);
  @$pb.TagNumber(3)
  void clearCvssScore() => clearField(3);

  /// Required. The set of affected locations and their fixes (if available)
  /// within the associated resource.
  @$pb.TagNumber(4)
  $core.List<PackageIssue> get packageIssue => $_getList(3);

  /// Output only. A one sentence description of this vulnerability.
  @$pb.TagNumber(5)
  $core.String get shortDescription => $_getSZ(4);
  @$pb.TagNumber(5)
  set shortDescription($core.String v) {
    $_setString(4, v);
  }

  @$pb.TagNumber(5)
  $core.bool hasShortDescription() => $_has(4);
  @$pb.TagNumber(5)
  void clearShortDescription() => clearField(5);

  /// Output only. A detailed description of this vulnerability.
  @$pb.TagNumber(6)
  $core.String get longDescription => $_getSZ(5);
  @$pb.TagNumber(6)
  set longDescription($core.String v) {
    $_setString(5, v);
  }

  @$pb.TagNumber(6)
  $core.bool hasLongDescription() => $_has(5);
  @$pb.TagNumber(6)
  void clearLongDescription() => clearField(6);

  /// Output only. URLs related to this vulnerability.
  @$pb.TagNumber(7)
  $core.List<$3.RelatedUrl> get relatedUrls => $_getList(6);

  /// The distro assigned severity for this vulnerability when it is
  /// available, and note provider assigned severity when distro has not yet
  /// assigned a severity for this vulnerability.
  @$pb.TagNumber(8)
  Severity get effectiveSeverity => $_getN(7);
  @$pb.TagNumber(8)
  set effectiveSeverity(Severity v) {
    setField(8, v);
  }

  @$pb.TagNumber(8)
  $core.bool hasEffectiveSeverity() => $_has(7);
  @$pb.TagNumber(8)
  void clearEffectiveSeverity() => clearField(8);
}

/// This message wraps a location affected by a vulnerability and its
/// associated fix (if one is available).
class PackageIssue extends $pb.GeneratedMessage {
  factory PackageIssue({
    VulnerabilityLocation? affectedLocation,
    VulnerabilityLocation? fixedLocation,
    $core.String? severityName,
  }) {
    final $result = create();
    if (affectedLocation != null) {
      $result.affectedLocation = affectedLocation;
    }
    if (fixedLocation != null) {
      $result.fixedLocation = fixedLocation;
    }
    if (severityName != null) {
      $result.severityName = severityName;
    }
    return $result;
  }
  PackageIssue._() : super();
  factory PackageIssue.fromBuffer($core.List<$core.int> i,
          [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) =>
      create()..mergeFromBuffer(i, r);
  factory PackageIssue.fromJson($core.String i,
          [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) =>
      create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(
      _omitMessageNames ? '' : 'PackageIssue',
      package: const $pb.PackageName(
          _omitMessageNames ? '' : 'grafeas.v1beta1.vulnerability'),
      createEmptyInstance: create)
    ..aOM<VulnerabilityLocation>(1, _omitFieldNames ? '' : 'affectedLocation',
        subBuilder: VulnerabilityLocation.create)
    ..aOM<VulnerabilityLocation>(2, _omitFieldNames ? '' : 'fixedLocation',
        subBuilder: VulnerabilityLocation.create)
    ..aOS(3, _omitFieldNames ? '' : 'severityName')
    ..hasRequiredFields = false;

  @$core.Deprecated('Using this can add significant overhead to your binary. '
      'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
      'Will be removed in next major version')
  PackageIssue clone() => PackageIssue()..mergeFromMessage(this);
  @$core.Deprecated('Using this can add significant overhead to your binary. '
      'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
      'Will be removed in next major version')
  PackageIssue copyWith(void Function(PackageIssue) updates) =>
      super.copyWith((message) => updates(message as PackageIssue))
          as PackageIssue;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static PackageIssue create() => PackageIssue._();
  PackageIssue createEmptyInstance() => create();
  static $pb.PbList<PackageIssue> createRepeated() =>
      $pb.PbList<PackageIssue>();
  @$core.pragma('dart2js:noInline')
  static PackageIssue getDefault() => _defaultInstance ??=
      $pb.GeneratedMessage.$_defaultFor<PackageIssue>(create);
  static PackageIssue? _defaultInstance;

  /// Required. The location of the vulnerability.
  @$pb.TagNumber(1)
  VulnerabilityLocation get affectedLocation => $_getN(0);
  @$pb.TagNumber(1)
  set affectedLocation(VulnerabilityLocation v) {
    setField(1, v);
  }

  @$pb.TagNumber(1)
  $core.bool hasAffectedLocation() => $_has(0);
  @$pb.TagNumber(1)
  void clearAffectedLocation() => clearField(1);
  @$pb.TagNumber(1)
  VulnerabilityLocation ensureAffectedLocation() => $_ensure(0);

  /// The location of the available fix for vulnerability.
  @$pb.TagNumber(2)
  VulnerabilityLocation get fixedLocation => $_getN(1);
  @$pb.TagNumber(2)
  set fixedLocation(VulnerabilityLocation v) {
    setField(2, v);
  }

  @$pb.TagNumber(2)
  $core.bool hasFixedLocation() => $_has(1);
  @$pb.TagNumber(2)
  void clearFixedLocation() => clearField(2);
  @$pb.TagNumber(2)
  VulnerabilityLocation ensureFixedLocation() => $_ensure(1);

  /// Deprecated, use Details.effective_severity instead
  /// The severity (e.g., distro assigned severity) for this vulnerability.
  @$pb.TagNumber(3)
  $core.String get severityName => $_getSZ(2);
  @$pb.TagNumber(3)
  set severityName($core.String v) {
    $_setString(2, v);
  }

  @$pb.TagNumber(3)
  $core.bool hasSeverityName() => $_has(2);
  @$pb.TagNumber(3)
  void clearSeverityName() => clearField(3);
}

/// The location of the vulnerability.
class VulnerabilityLocation extends $pb.GeneratedMessage {
  factory VulnerabilityLocation({
    $core.String? cpeUri,
    $core.String? package,
    $2.Version? version,
  }) {
    final $result = create();
    if (cpeUri != null) {
      $result.cpeUri = cpeUri;
    }
    if (package != null) {
      $result.package = package;
    }
    if (version != null) {
      $result.version = version;
    }
    return $result;
  }
  VulnerabilityLocation._() : super();
  factory VulnerabilityLocation.fromBuffer($core.List<$core.int> i,
          [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) =>
      create()..mergeFromBuffer(i, r);
  factory VulnerabilityLocation.fromJson($core.String i,
          [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) =>
      create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(
      _omitMessageNames ? '' : 'VulnerabilityLocation',
      package: const $pb.PackageName(
          _omitMessageNames ? '' : 'grafeas.v1beta1.vulnerability'),
      createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'cpeUri')
    ..aOS(2, _omitFieldNames ? '' : 'package')
    ..aOM<$2.Version>(3, _omitFieldNames ? '' : 'version',
        subBuilder: $2.Version.create)
    ..hasRequiredFields = false;

  @$core.Deprecated('Using this can add significant overhead to your binary. '
      'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
      'Will be removed in next major version')
  VulnerabilityLocation clone() =>
      VulnerabilityLocation()..mergeFromMessage(this);
  @$core.Deprecated('Using this can add significant overhead to your binary. '
      'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
      'Will be removed in next major version')
  VulnerabilityLocation copyWith(
          void Function(VulnerabilityLocation) updates) =>
      super.copyWith((message) => updates(message as VulnerabilityLocation))
          as VulnerabilityLocation;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static VulnerabilityLocation create() => VulnerabilityLocation._();
  VulnerabilityLocation createEmptyInstance() => create();
  static $pb.PbList<VulnerabilityLocation> createRepeated() =>
      $pb.PbList<VulnerabilityLocation>();
  @$core.pragma('dart2js:noInline')
  static VulnerabilityLocation getDefault() => _defaultInstance ??=
      $pb.GeneratedMessage.$_defaultFor<VulnerabilityLocation>(create);
  static VulnerabilityLocation? _defaultInstance;

  /// Required. The CPE URI in [cpe format](https://cpe.mitre.org/specification/)
  /// format. Examples include distro or storage location for vulnerable jar.
  @$pb.TagNumber(1)
  $core.String get cpeUri => $_getSZ(0);
  @$pb.TagNumber(1)
  set cpeUri($core.String v) {
    $_setString(0, v);
  }

  @$pb.TagNumber(1)
  $core.bool hasCpeUri() => $_has(0);
  @$pb.TagNumber(1)
  void clearCpeUri() => clearField(1);

  /// Required. The package being described.
  @$pb.TagNumber(2)
  $core.String get package => $_getSZ(1);
  @$pb.TagNumber(2)
  set package($core.String v) {
    $_setString(1, v);
  }

  @$pb.TagNumber(2)
  $core.bool hasPackage() => $_has(1);
  @$pb.TagNumber(2)
  void clearPackage() => clearField(2);

  /// Required. The version of the package being described.
  @$pb.TagNumber(3)
  $2.Version get version => $_getN(2);
  @$pb.TagNumber(3)
  set version($2.Version v) {
    setField(3, v);
  }

  @$pb.TagNumber(3)
  $core.bool hasVersion() => $_has(2);
  @$pb.TagNumber(3)
  void clearVersion() => clearField(3);
  @$pb.TagNumber(3)
  $2.Version ensureVersion() => $_ensure(2);
}

const _omitFieldNames = $core.bool.fromEnvironment('protobuf.omit_field_names');
const _omitMessageNames =
    $core.bool.fromEnvironment('protobuf.omit_message_names');
