// This is a generated file - do not edit.
//
// Generated from grafeas/v1/vulnerability.proto.

// @dart = 3.3

// ignore_for_file: annotate_overrides, camel_case_types, comment_references
// ignore_for_file: constant_identifier_names
// ignore_for_file: curly_braces_in_flow_control_structures
// ignore_for_file: deprecated_member_use_from_same_package, library_prefixes
// ignore_for_file: non_constant_identifier_names, prefer_relative_imports

import 'dart:core' as $core;

import 'package:protobuf/protobuf.dart' as $pb;
import 'package:grpc_googleapis/src/generated/google/protobuf/timestamp.pb.dart'
    as $1;

import 'common.pb.dart' as $3;
import 'cvss.pb.dart' as $0;
import 'package.pb.dart' as $2;
import 'risk.pb.dart' as $4;
import 'severity.pbenum.dart' as $6;
import 'vex.pb.dart' as $5;

export 'package:protobuf/protobuf.dart' show GeneratedMessageGenericExtensions;

/// A detail for a distro and package affected by this vulnerability and its
/// associated fix (if one is available).
class VulnerabilityNote_Detail extends $pb.GeneratedMessage {
  factory VulnerabilityNote_Detail({
    $core.String? severityName,
    $core.String? description,
    $core.String? packageType,
    $core.String? affectedCpeUri,
    $core.String? affectedPackage,
    $2.Version? affectedVersionStart,
    $2.Version? affectedVersionEnd,
    $core.String? fixedCpeUri,
    $core.String? fixedPackage,
    $2.Version? fixedVersion,
    $core.bool? isObsolete,
    $1.Timestamp? sourceUpdateTime,
    $core.String? source,
    $core.String? vendor,
  }) {
    final result = create();
    if (severityName != null) result.severityName = severityName;
    if (description != null) result.description = description;
    if (packageType != null) result.packageType = packageType;
    if (affectedCpeUri != null) result.affectedCpeUri = affectedCpeUri;
    if (affectedPackage != null) result.affectedPackage = affectedPackage;
    if (affectedVersionStart != null)
      result.affectedVersionStart = affectedVersionStart;
    if (affectedVersionEnd != null)
      result.affectedVersionEnd = affectedVersionEnd;
    if (fixedCpeUri != null) result.fixedCpeUri = fixedCpeUri;
    if (fixedPackage != null) result.fixedPackage = fixedPackage;
    if (fixedVersion != null) result.fixedVersion = fixedVersion;
    if (isObsolete != null) result.isObsolete = isObsolete;
    if (sourceUpdateTime != null) result.sourceUpdateTime = sourceUpdateTime;
    if (source != null) result.source = source;
    if (vendor != null) result.vendor = vendor;
    return result;
  }

  VulnerabilityNote_Detail._();

  factory VulnerabilityNote_Detail.fromBuffer($core.List<$core.int> data,
          [$pb.ExtensionRegistry registry = $pb.ExtensionRegistry.EMPTY]) =>
      create()..mergeFromBuffer(data, registry);
  factory VulnerabilityNote_Detail.fromJson($core.String json,
          [$pb.ExtensionRegistry registry = $pb.ExtensionRegistry.EMPTY]) =>
      create()..mergeFromJson(json, registry);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(
      _omitMessageNames ? '' : 'VulnerabilityNote.Detail',
      package: const $pb.PackageName(_omitMessageNames ? '' : 'grafeas.v1'),
      createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'severityName')
    ..aOS(2, _omitFieldNames ? '' : 'description')
    ..aOS(3, _omitFieldNames ? '' : 'packageType')
    ..aOS(4, _omitFieldNames ? '' : 'affectedCpeUri')
    ..aOS(5, _omitFieldNames ? '' : 'affectedPackage')
    ..aOM<$2.Version>(6, _omitFieldNames ? '' : 'affectedVersionStart',
        subBuilder: $2.Version.create)
    ..aOM<$2.Version>(7, _omitFieldNames ? '' : 'affectedVersionEnd',
        subBuilder: $2.Version.create)
    ..aOS(8, _omitFieldNames ? '' : 'fixedCpeUri')
    ..aOS(9, _omitFieldNames ? '' : 'fixedPackage')
    ..aOM<$2.Version>(10, _omitFieldNames ? '' : 'fixedVersion',
        subBuilder: $2.Version.create)
    ..aOB(11, _omitFieldNames ? '' : 'isObsolete')
    ..aOM<$1.Timestamp>(12, _omitFieldNames ? '' : 'sourceUpdateTime',
        subBuilder: $1.Timestamp.create)
    ..aOS(13, _omitFieldNames ? '' : 'source')
    ..aOS(14, _omitFieldNames ? '' : 'vendor')
    ..hasRequiredFields = false;

  @$core.Deprecated('See https://github.com/google/protobuf.dart/issues/998.')
  VulnerabilityNote_Detail clone() => deepCopy();
  @$core.Deprecated('See https://github.com/google/protobuf.dart/issues/998.')
  VulnerabilityNote_Detail copyWith(
          void Function(VulnerabilityNote_Detail) updates) =>
      super.copyWith((message) => updates(message as VulnerabilityNote_Detail))
          as VulnerabilityNote_Detail;

  @$core.override
  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static VulnerabilityNote_Detail create() => VulnerabilityNote_Detail._();
  @$core.override
  VulnerabilityNote_Detail createEmptyInstance() => create();
  @$core.pragma('dart2js:noInline')
  static VulnerabilityNote_Detail getDefault() => _defaultInstance ??=
      $pb.GeneratedMessage.$_defaultFor<VulnerabilityNote_Detail>(create);
  static VulnerabilityNote_Detail? _defaultInstance;

  /// The distro assigned severity of this vulnerability.
  @$pb.TagNumber(1)
  $core.String get severityName => $_getSZ(0);
  @$pb.TagNumber(1)
  set severityName($core.String value) => $_setString(0, value);
  @$pb.TagNumber(1)
  $core.bool hasSeverityName() => $_has(0);
  @$pb.TagNumber(1)
  void clearSeverityName() => $_clearField(1);

  /// A vendor-specific description of this vulnerability.
  @$pb.TagNumber(2)
  $core.String get description => $_getSZ(1);
  @$pb.TagNumber(2)
  set description($core.String value) => $_setString(1, value);
  @$pb.TagNumber(2)
  $core.bool hasDescription() => $_has(1);
  @$pb.TagNumber(2)
  void clearDescription() => $_clearField(2);

  /// The type of package; whether native or non native (e.g., ruby gems,
  /// node.js packages, etc.).
  @$pb.TagNumber(3)
  $core.String get packageType => $_getSZ(2);
  @$pb.TagNumber(3)
  set packageType($core.String value) => $_setString(2, value);
  @$pb.TagNumber(3)
  $core.bool hasPackageType() => $_has(2);
  @$pb.TagNumber(3)
  void clearPackageType() => $_clearField(3);

  /// Required. The [CPE URI](https://cpe.mitre.org/specification/) this
  /// vulnerability affects.
  @$pb.TagNumber(4)
  $core.String get affectedCpeUri => $_getSZ(3);
  @$pb.TagNumber(4)
  set affectedCpeUri($core.String value) => $_setString(3, value);
  @$pb.TagNumber(4)
  $core.bool hasAffectedCpeUri() => $_has(3);
  @$pb.TagNumber(4)
  void clearAffectedCpeUri() => $_clearField(4);

  /// Required. The package this vulnerability affects.
  @$pb.TagNumber(5)
  $core.String get affectedPackage => $_getSZ(4);
  @$pb.TagNumber(5)
  set affectedPackage($core.String value) => $_setString(4, value);
  @$pb.TagNumber(5)
  $core.bool hasAffectedPackage() => $_has(4);
  @$pb.TagNumber(5)
  void clearAffectedPackage() => $_clearField(5);

  /// The version number at the start of an interval in which this vulnerability
  /// exists. A vulnerability can affect a package between version numbers
  /// that are disjoint sets of intervals (example: [1.0.0-1.1.0], [2.4.6-2.4.8]
  /// and [4.5.6-4.6.8]) each of which will be represented in its own Detail.
  /// If a specific affected version is provided by a vulnerability database,
  /// affected_version_start and affected_version_end will be the same in that
  /// Detail.
  @$pb.TagNumber(6)
  $2.Version get affectedVersionStart => $_getN(5);
  @$pb.TagNumber(6)
  set affectedVersionStart($2.Version value) => $_setField(6, value);
  @$pb.TagNumber(6)
  $core.bool hasAffectedVersionStart() => $_has(5);
  @$pb.TagNumber(6)
  void clearAffectedVersionStart() => $_clearField(6);
  @$pb.TagNumber(6)
  $2.Version ensureAffectedVersionStart() => $_ensure(5);

  /// The version number at the end of an interval in which this vulnerability
  /// exists. A vulnerability can affect a package between version numbers
  /// that are disjoint sets of intervals (example: [1.0.0-1.1.0], [2.4.6-2.4.8]
  /// and [4.5.6-4.6.8]) each of which will be represented in its own Detail.
  /// If a specific affected version is provided by a vulnerability database,
  /// affected_version_start and affected_version_end will be the same in that
  /// Detail.
  @$pb.TagNumber(7)
  $2.Version get affectedVersionEnd => $_getN(6);
  @$pb.TagNumber(7)
  set affectedVersionEnd($2.Version value) => $_setField(7, value);
  @$pb.TagNumber(7)
  $core.bool hasAffectedVersionEnd() => $_has(6);
  @$pb.TagNumber(7)
  void clearAffectedVersionEnd() => $_clearField(7);
  @$pb.TagNumber(7)
  $2.Version ensureAffectedVersionEnd() => $_ensure(6);

  /// The distro recommended [CPE URI](https://cpe.mitre.org/specification/)
  /// to update to that contains a fix for this vulnerability. It is possible
  /// for this to be different from the affected_cpe_uri.
  @$pb.TagNumber(8)
  $core.String get fixedCpeUri => $_getSZ(7);
  @$pb.TagNumber(8)
  set fixedCpeUri($core.String value) => $_setString(7, value);
  @$pb.TagNumber(8)
  $core.bool hasFixedCpeUri() => $_has(7);
  @$pb.TagNumber(8)
  void clearFixedCpeUri() => $_clearField(8);

  /// The distro recommended package to update to that contains a fix for this
  /// vulnerability. It is possible for this to be different from the affected_package.
  @$pb.TagNumber(9)
  $core.String get fixedPackage => $_getSZ(8);
  @$pb.TagNumber(9)
  set fixedPackage($core.String value) => $_setString(8, value);
  @$pb.TagNumber(9)
  $core.bool hasFixedPackage() => $_has(8);
  @$pb.TagNumber(9)
  void clearFixedPackage() => $_clearField(9);

  /// The distro recommended version to update to that contains a
  /// fix for this vulnerability. Setting this to VersionKind.MAXIMUM means no
  /// such version is yet available.
  @$pb.TagNumber(10)
  $2.Version get fixedVersion => $_getN(9);
  @$pb.TagNumber(10)
  set fixedVersion($2.Version value) => $_setField(10, value);
  @$pb.TagNumber(10)
  $core.bool hasFixedVersion() => $_has(9);
  @$pb.TagNumber(10)
  void clearFixedVersion() => $_clearField(10);
  @$pb.TagNumber(10)
  $2.Version ensureFixedVersion() => $_ensure(9);

  /// Whether this detail is obsolete. Occurrences are expected not to point to
  /// obsolete details.
  @$pb.TagNumber(11)
  $core.bool get isObsolete => $_getBF(10);
  @$pb.TagNumber(11)
  set isObsolete($core.bool value) => $_setBool(10, value);
  @$pb.TagNumber(11)
  $core.bool hasIsObsolete() => $_has(10);
  @$pb.TagNumber(11)
  void clearIsObsolete() => $_clearField(11);

  /// The time this information was last changed at the source. This is an
  /// upstream timestamp from the underlying information source - e.g. Ubuntu
  /// security tracker.
  @$pb.TagNumber(12)
  $1.Timestamp get sourceUpdateTime => $_getN(11);
  @$pb.TagNumber(12)
  set sourceUpdateTime($1.Timestamp value) => $_setField(12, value);
  @$pb.TagNumber(12)
  $core.bool hasSourceUpdateTime() => $_has(11);
  @$pb.TagNumber(12)
  void clearSourceUpdateTime() => $_clearField(12);
  @$pb.TagNumber(12)
  $1.Timestamp ensureSourceUpdateTime() => $_ensure(11);

  /// The source from which the information in this Detail was obtained.
  @$pb.TagNumber(13)
  $core.String get source => $_getSZ(12);
  @$pb.TagNumber(13)
  set source($core.String value) => $_setString(12, value);
  @$pb.TagNumber(13)
  $core.bool hasSource() => $_has(12);
  @$pb.TagNumber(13)
  void clearSource() => $_clearField(13);

  /// The name of the vendor of the product.
  @$pb.TagNumber(14)
  $core.String get vendor => $_getSZ(13);
  @$pb.TagNumber(14)
  set vendor($core.String value) => $_setString(13, value);
  @$pb.TagNumber(14)
  $core.bool hasVendor() => $_has(13);
  @$pb.TagNumber(14)
  void clearVendor() => $_clearField(14);
}

class VulnerabilityNote_WindowsDetail_KnowledgeBase
    extends $pb.GeneratedMessage {
  factory VulnerabilityNote_WindowsDetail_KnowledgeBase({
    $core.String? name,
    $core.String? url,
  }) {
    final result = create();
    if (name != null) result.name = name;
    if (url != null) result.url = url;
    return result;
  }

  VulnerabilityNote_WindowsDetail_KnowledgeBase._();

  factory VulnerabilityNote_WindowsDetail_KnowledgeBase.fromBuffer(
          $core.List<$core.int> data,
          [$pb.ExtensionRegistry registry = $pb.ExtensionRegistry.EMPTY]) =>
      create()..mergeFromBuffer(data, registry);
  factory VulnerabilityNote_WindowsDetail_KnowledgeBase.fromJson(
          $core.String json,
          [$pb.ExtensionRegistry registry = $pb.ExtensionRegistry.EMPTY]) =>
      create()..mergeFromJson(json, registry);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(
      _omitMessageNames ? '' : 'VulnerabilityNote.WindowsDetail.KnowledgeBase',
      package: const $pb.PackageName(_omitMessageNames ? '' : 'grafeas.v1'),
      createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'name')
    ..aOS(2, _omitFieldNames ? '' : 'url')
    ..hasRequiredFields = false;

  @$core.Deprecated('See https://github.com/google/protobuf.dart/issues/998.')
  VulnerabilityNote_WindowsDetail_KnowledgeBase clone() => deepCopy();
  @$core.Deprecated('See https://github.com/google/protobuf.dart/issues/998.')
  VulnerabilityNote_WindowsDetail_KnowledgeBase copyWith(
          void Function(VulnerabilityNote_WindowsDetail_KnowledgeBase)
              updates) =>
      super.copyWith((message) =>
              updates(message as VulnerabilityNote_WindowsDetail_KnowledgeBase))
          as VulnerabilityNote_WindowsDetail_KnowledgeBase;

  @$core.override
  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static VulnerabilityNote_WindowsDetail_KnowledgeBase create() =>
      VulnerabilityNote_WindowsDetail_KnowledgeBase._();
  @$core.override
  VulnerabilityNote_WindowsDetail_KnowledgeBase createEmptyInstance() =>
      create();
  @$core.pragma('dart2js:noInline')
  static VulnerabilityNote_WindowsDetail_KnowledgeBase getDefault() =>
      _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<
          VulnerabilityNote_WindowsDetail_KnowledgeBase>(create);
  static VulnerabilityNote_WindowsDetail_KnowledgeBase? _defaultInstance;

  /// The KB name (generally of the form KB[0-9]+ (e.g., KB123456)).
  @$pb.TagNumber(1)
  $core.String get name => $_getSZ(0);
  @$pb.TagNumber(1)
  set name($core.String value) => $_setString(0, value);
  @$pb.TagNumber(1)
  $core.bool hasName() => $_has(0);
  @$pb.TagNumber(1)
  void clearName() => $_clearField(1);

  /// A link to the KB in the [Windows update catalog]
  /// (https://www.catalog.update.microsoft.com/).
  @$pb.TagNumber(2)
  $core.String get url => $_getSZ(1);
  @$pb.TagNumber(2)
  set url($core.String value) => $_setString(1, value);
  @$pb.TagNumber(2)
  $core.bool hasUrl() => $_has(1);
  @$pb.TagNumber(2)
  void clearUrl() => $_clearField(2);
}

class VulnerabilityNote_WindowsDetail extends $pb.GeneratedMessage {
  factory VulnerabilityNote_WindowsDetail({
    $core.String? cpeUri,
    $core.String? name,
    $core.String? description,
    $core.Iterable<VulnerabilityNote_WindowsDetail_KnowledgeBase>? fixingKbs,
  }) {
    final result = create();
    if (cpeUri != null) result.cpeUri = cpeUri;
    if (name != null) result.name = name;
    if (description != null) result.description = description;
    if (fixingKbs != null) result.fixingKbs.addAll(fixingKbs);
    return result;
  }

  VulnerabilityNote_WindowsDetail._();

  factory VulnerabilityNote_WindowsDetail.fromBuffer($core.List<$core.int> data,
          [$pb.ExtensionRegistry registry = $pb.ExtensionRegistry.EMPTY]) =>
      create()..mergeFromBuffer(data, registry);
  factory VulnerabilityNote_WindowsDetail.fromJson($core.String json,
          [$pb.ExtensionRegistry registry = $pb.ExtensionRegistry.EMPTY]) =>
      create()..mergeFromJson(json, registry);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(
      _omitMessageNames ? '' : 'VulnerabilityNote.WindowsDetail',
      package: const $pb.PackageName(_omitMessageNames ? '' : 'grafeas.v1'),
      createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'cpeUri')
    ..aOS(2, _omitFieldNames ? '' : 'name')
    ..aOS(3, _omitFieldNames ? '' : 'description')
    ..pPM<VulnerabilityNote_WindowsDetail_KnowledgeBase>(
        4, _omitFieldNames ? '' : 'fixingKbs',
        subBuilder: VulnerabilityNote_WindowsDetail_KnowledgeBase.create)
    ..hasRequiredFields = false;

  @$core.Deprecated('See https://github.com/google/protobuf.dart/issues/998.')
  VulnerabilityNote_WindowsDetail clone() => deepCopy();
  @$core.Deprecated('See https://github.com/google/protobuf.dart/issues/998.')
  VulnerabilityNote_WindowsDetail copyWith(
          void Function(VulnerabilityNote_WindowsDetail) updates) =>
      super.copyWith(
              (message) => updates(message as VulnerabilityNote_WindowsDetail))
          as VulnerabilityNote_WindowsDetail;

  @$core.override
  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static VulnerabilityNote_WindowsDetail create() =>
      VulnerabilityNote_WindowsDetail._();
  @$core.override
  VulnerabilityNote_WindowsDetail createEmptyInstance() => create();
  @$core.pragma('dart2js:noInline')
  static VulnerabilityNote_WindowsDetail getDefault() => _defaultInstance ??=
      $pb.GeneratedMessage.$_defaultFor<VulnerabilityNote_WindowsDetail>(
          create);
  static VulnerabilityNote_WindowsDetail? _defaultInstance;

  /// Required. The [CPE URI](https://cpe.mitre.org/specification/) this
  /// vulnerability affects.
  @$pb.TagNumber(1)
  $core.String get cpeUri => $_getSZ(0);
  @$pb.TagNumber(1)
  set cpeUri($core.String value) => $_setString(0, value);
  @$pb.TagNumber(1)
  $core.bool hasCpeUri() => $_has(0);
  @$pb.TagNumber(1)
  void clearCpeUri() => $_clearField(1);

  /// Required. The name of this vulnerability.
  @$pb.TagNumber(2)
  $core.String get name => $_getSZ(1);
  @$pb.TagNumber(2)
  set name($core.String value) => $_setString(1, value);
  @$pb.TagNumber(2)
  $core.bool hasName() => $_has(1);
  @$pb.TagNumber(2)
  void clearName() => $_clearField(2);

  /// The description of this vulnerability.
  @$pb.TagNumber(3)
  $core.String get description => $_getSZ(2);
  @$pb.TagNumber(3)
  set description($core.String value) => $_setString(2, value);
  @$pb.TagNumber(3)
  $core.bool hasDescription() => $_has(2);
  @$pb.TagNumber(3)
  void clearDescription() => $_clearField(3);

  /// Required. The names of the KBs which have hotfixes to mitigate this
  /// vulnerability. Note that there may be multiple hotfixes (and thus
  /// multiple KBs) that mitigate a given vulnerability. Currently any listed
  /// KBs presence is considered a fix.
  @$pb.TagNumber(4)
  $pb.PbList<VulnerabilityNote_WindowsDetail_KnowledgeBase> get fixingKbs =>
      $_getList(3);
}

/// A security vulnerability that can be found in resources.
class VulnerabilityNote extends $pb.GeneratedMessage {
  factory VulnerabilityNote({
    $core.double? cvssScore,
    $6.Severity? severity,
    $core.Iterable<VulnerabilityNote_Detail>? details,
    $0.CVSSv3? cvssV3,
    $core.Iterable<VulnerabilityNote_WindowsDetail>? windowsDetails,
    $1.Timestamp? sourceUpdateTime,
    $0.CVSSVersion? cvssVersion,
    $0.CVSS? cvssV2,
  }) {
    final result = create();
    if (cvssScore != null) result.cvssScore = cvssScore;
    if (severity != null) result.severity = severity;
    if (details != null) result.details.addAll(details);
    if (cvssV3 != null) result.cvssV3 = cvssV3;
    if (windowsDetails != null) result.windowsDetails.addAll(windowsDetails);
    if (sourceUpdateTime != null) result.sourceUpdateTime = sourceUpdateTime;
    if (cvssVersion != null) result.cvssVersion = cvssVersion;
    if (cvssV2 != null) result.cvssV2 = cvssV2;
    return result;
  }

  VulnerabilityNote._();

  factory VulnerabilityNote.fromBuffer($core.List<$core.int> data,
          [$pb.ExtensionRegistry registry = $pb.ExtensionRegistry.EMPTY]) =>
      create()..mergeFromBuffer(data, registry);
  factory VulnerabilityNote.fromJson($core.String json,
          [$pb.ExtensionRegistry registry = $pb.ExtensionRegistry.EMPTY]) =>
      create()..mergeFromJson(json, registry);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(
      _omitMessageNames ? '' : 'VulnerabilityNote',
      package: const $pb.PackageName(_omitMessageNames ? '' : 'grafeas.v1'),
      createEmptyInstance: create)
    ..aD(1, _omitFieldNames ? '' : 'cvssScore', fieldType: $pb.PbFieldType.OF)
    ..aE<$6.Severity>(2, _omitFieldNames ? '' : 'severity',
        enumValues: $6.Severity.values)
    ..pPM<VulnerabilityNote_Detail>(3, _omitFieldNames ? '' : 'details',
        subBuilder: VulnerabilityNote_Detail.create)
    ..aOM<$0.CVSSv3>(4, _omitFieldNames ? '' : 'cvssV3',
        subBuilder: $0.CVSSv3.create)
    ..pPM<VulnerabilityNote_WindowsDetail>(
        5, _omitFieldNames ? '' : 'windowsDetails',
        subBuilder: VulnerabilityNote_WindowsDetail.create)
    ..aOM<$1.Timestamp>(6, _omitFieldNames ? '' : 'sourceUpdateTime',
        subBuilder: $1.Timestamp.create)
    ..aE<$0.CVSSVersion>(7, _omitFieldNames ? '' : 'cvssVersion',
        enumValues: $0.CVSSVersion.values)
    ..aOM<$0.CVSS>(8, _omitFieldNames ? '' : 'cvssV2',
        subBuilder: $0.CVSS.create)
    ..hasRequiredFields = false;

  @$core.Deprecated('See https://github.com/google/protobuf.dart/issues/998.')
  VulnerabilityNote clone() => deepCopy();
  @$core.Deprecated('See https://github.com/google/protobuf.dart/issues/998.')
  VulnerabilityNote copyWith(void Function(VulnerabilityNote) updates) =>
      super.copyWith((message) => updates(message as VulnerabilityNote))
          as VulnerabilityNote;

  @$core.override
  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static VulnerabilityNote create() => VulnerabilityNote._();
  @$core.override
  VulnerabilityNote createEmptyInstance() => create();
  @$core.pragma('dart2js:noInline')
  static VulnerabilityNote getDefault() => _defaultInstance ??=
      $pb.GeneratedMessage.$_defaultFor<VulnerabilityNote>(create);
  static VulnerabilityNote? _defaultInstance;

  /// The CVSS score of this vulnerability. CVSS score is on a scale of 0 - 10
  /// where 0 indicates low severity and 10 indicates high severity.
  @$pb.TagNumber(1)
  $core.double get cvssScore => $_getN(0);
  @$pb.TagNumber(1)
  set cvssScore($core.double value) => $_setFloat(0, value);
  @$pb.TagNumber(1)
  $core.bool hasCvssScore() => $_has(0);
  @$pb.TagNumber(1)
  void clearCvssScore() => $_clearField(1);

  /// The note provider assigned severity of this vulnerability.
  @$pb.TagNumber(2)
  $6.Severity get severity => $_getN(1);
  @$pb.TagNumber(2)
  set severity($6.Severity value) => $_setField(2, value);
  @$pb.TagNumber(2)
  $core.bool hasSeverity() => $_has(1);
  @$pb.TagNumber(2)
  void clearSeverity() => $_clearField(2);

  /// Details of all known distros and packages affected by this vulnerability.
  @$pb.TagNumber(3)
  $pb.PbList<VulnerabilityNote_Detail> get details => $_getList(2);

  /// The full description of the CVSSv3 for this vulnerability.
  @$pb.TagNumber(4)
  $0.CVSSv3 get cvssV3 => $_getN(3);
  @$pb.TagNumber(4)
  set cvssV3($0.CVSSv3 value) => $_setField(4, value);
  @$pb.TagNumber(4)
  $core.bool hasCvssV3() => $_has(3);
  @$pb.TagNumber(4)
  void clearCvssV3() => $_clearField(4);
  @$pb.TagNumber(4)
  $0.CVSSv3 ensureCvssV3() => $_ensure(3);

  /// Windows details get their own format because the information format and
  /// model don't match a normal detail. Specifically Windows updates are done as
  /// patches, thus Windows vulnerabilities really are a missing package, rather
  /// than a package being at an incorrect version.
  @$pb.TagNumber(5)
  $pb.PbList<VulnerabilityNote_WindowsDetail> get windowsDetails =>
      $_getList(4);

  /// The time this information was last changed at the source. This is an
  /// upstream timestamp from the underlying information source - e.g. Ubuntu
  /// security tracker.
  @$pb.TagNumber(6)
  $1.Timestamp get sourceUpdateTime => $_getN(5);
  @$pb.TagNumber(6)
  set sourceUpdateTime($1.Timestamp value) => $_setField(6, value);
  @$pb.TagNumber(6)
  $core.bool hasSourceUpdateTime() => $_has(5);
  @$pb.TagNumber(6)
  void clearSourceUpdateTime() => $_clearField(6);
  @$pb.TagNumber(6)
  $1.Timestamp ensureSourceUpdateTime() => $_ensure(5);

  /// CVSS version used to populate cvss_score and severity.
  @$pb.TagNumber(7)
  $0.CVSSVersion get cvssVersion => $_getN(6);
  @$pb.TagNumber(7)
  set cvssVersion($0.CVSSVersion value) => $_setField(7, value);
  @$pb.TagNumber(7)
  $core.bool hasCvssVersion() => $_has(6);
  @$pb.TagNumber(7)
  void clearCvssVersion() => $_clearField(7);

  /// The full description of the v2 CVSS for this vulnerability.
  @$pb.TagNumber(8)
  $0.CVSS get cvssV2 => $_getN(7);
  @$pb.TagNumber(8)
  set cvssV2($0.CVSS value) => $_setField(8, value);
  @$pb.TagNumber(8)
  $core.bool hasCvssV2() => $_has(7);
  @$pb.TagNumber(8)
  void clearCvssV2() => $_clearField(8);
  @$pb.TagNumber(8)
  $0.CVSS ensureCvssV2() => $_ensure(7);
}

/// A detail for a distro and package this vulnerability occurrence was found in
/// and its associated fix (if one is available).
class VulnerabilityOccurrence_PackageIssue extends $pb.GeneratedMessage {
  factory VulnerabilityOccurrence_PackageIssue({
    $core.String? affectedCpeUri,
    $core.String? affectedPackage,
    $2.Version? affectedVersion,
    $core.String? fixedCpeUri,
    $core.String? fixedPackage,
    $2.Version? fixedVersion,
    $core.bool? fixAvailable,
    $core.String? packageType,
    $6.Severity? effectiveSeverity,
    $core.Iterable<$3.FileLocation>? fileLocation,
  }) {
    final result = create();
    if (affectedCpeUri != null) result.affectedCpeUri = affectedCpeUri;
    if (affectedPackage != null) result.affectedPackage = affectedPackage;
    if (affectedVersion != null) result.affectedVersion = affectedVersion;
    if (fixedCpeUri != null) result.fixedCpeUri = fixedCpeUri;
    if (fixedPackage != null) result.fixedPackage = fixedPackage;
    if (fixedVersion != null) result.fixedVersion = fixedVersion;
    if (fixAvailable != null) result.fixAvailable = fixAvailable;
    if (packageType != null) result.packageType = packageType;
    if (effectiveSeverity != null) result.effectiveSeverity = effectiveSeverity;
    if (fileLocation != null) result.fileLocation.addAll(fileLocation);
    return result;
  }

  VulnerabilityOccurrence_PackageIssue._();

  factory VulnerabilityOccurrence_PackageIssue.fromBuffer(
          $core.List<$core.int> data,
          [$pb.ExtensionRegistry registry = $pb.ExtensionRegistry.EMPTY]) =>
      create()..mergeFromBuffer(data, registry);
  factory VulnerabilityOccurrence_PackageIssue.fromJson($core.String json,
          [$pb.ExtensionRegistry registry = $pb.ExtensionRegistry.EMPTY]) =>
      create()..mergeFromJson(json, registry);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(
      _omitMessageNames ? '' : 'VulnerabilityOccurrence.PackageIssue',
      package: const $pb.PackageName(_omitMessageNames ? '' : 'grafeas.v1'),
      createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'affectedCpeUri')
    ..aOS(2, _omitFieldNames ? '' : 'affectedPackage')
    ..aOM<$2.Version>(3, _omitFieldNames ? '' : 'affectedVersion',
        subBuilder: $2.Version.create)
    ..aOS(4, _omitFieldNames ? '' : 'fixedCpeUri')
    ..aOS(5, _omitFieldNames ? '' : 'fixedPackage')
    ..aOM<$2.Version>(6, _omitFieldNames ? '' : 'fixedVersion',
        subBuilder: $2.Version.create)
    ..aOB(7, _omitFieldNames ? '' : 'fixAvailable')
    ..aOS(8, _omitFieldNames ? '' : 'packageType')
    ..aE<$6.Severity>(9, _omitFieldNames ? '' : 'effectiveSeverity',
        enumValues: $6.Severity.values)
    ..pPM<$3.FileLocation>(10, _omitFieldNames ? '' : 'fileLocation',
        subBuilder: $3.FileLocation.create)
    ..hasRequiredFields = false;

  @$core.Deprecated('See https://github.com/google/protobuf.dart/issues/998.')
  VulnerabilityOccurrence_PackageIssue clone() => deepCopy();
  @$core.Deprecated('See https://github.com/google/protobuf.dart/issues/998.')
  VulnerabilityOccurrence_PackageIssue copyWith(
          void Function(VulnerabilityOccurrence_PackageIssue) updates) =>
      super.copyWith((message) =>
              updates(message as VulnerabilityOccurrence_PackageIssue))
          as VulnerabilityOccurrence_PackageIssue;

  @$core.override
  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static VulnerabilityOccurrence_PackageIssue create() =>
      VulnerabilityOccurrence_PackageIssue._();
  @$core.override
  VulnerabilityOccurrence_PackageIssue createEmptyInstance() => create();
  @$core.pragma('dart2js:noInline')
  static VulnerabilityOccurrence_PackageIssue getDefault() =>
      _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<
          VulnerabilityOccurrence_PackageIssue>(create);
  static VulnerabilityOccurrence_PackageIssue? _defaultInstance;

  /// Required. The [CPE URI](https://cpe.mitre.org/specification/) this
  /// vulnerability was found in.
  @$pb.TagNumber(1)
  $core.String get affectedCpeUri => $_getSZ(0);
  @$pb.TagNumber(1)
  set affectedCpeUri($core.String value) => $_setString(0, value);
  @$pb.TagNumber(1)
  $core.bool hasAffectedCpeUri() => $_has(0);
  @$pb.TagNumber(1)
  void clearAffectedCpeUri() => $_clearField(1);

  /// Required. The package this vulnerability was found in.
  @$pb.TagNumber(2)
  $core.String get affectedPackage => $_getSZ(1);
  @$pb.TagNumber(2)
  set affectedPackage($core.String value) => $_setString(1, value);
  @$pb.TagNumber(2)
  $core.bool hasAffectedPackage() => $_has(1);
  @$pb.TagNumber(2)
  void clearAffectedPackage() => $_clearField(2);

  /// Required. The version of the package that is installed on the resource
  /// affected by this vulnerability.
  @$pb.TagNumber(3)
  $2.Version get affectedVersion => $_getN(2);
  @$pb.TagNumber(3)
  set affectedVersion($2.Version value) => $_setField(3, value);
  @$pb.TagNumber(3)
  $core.bool hasAffectedVersion() => $_has(2);
  @$pb.TagNumber(3)
  void clearAffectedVersion() => $_clearField(3);
  @$pb.TagNumber(3)
  $2.Version ensureAffectedVersion() => $_ensure(2);

  /// The [CPE URI](https://cpe.mitre.org/specification/) this vulnerability was
  /// fixed in. It is possible for this to be different from
  /// the affected_cpe_uri.
  @$pb.TagNumber(4)
  $core.String get fixedCpeUri => $_getSZ(3);
  @$pb.TagNumber(4)
  set fixedCpeUri($core.String value) => $_setString(3, value);
  @$pb.TagNumber(4)
  $core.bool hasFixedCpeUri() => $_has(3);
  @$pb.TagNumber(4)
  void clearFixedCpeUri() => $_clearField(4);

  /// The package this vulnerability was fixed in. It is possible for this to be
  /// different from the affected_package.
  @$pb.TagNumber(5)
  $core.String get fixedPackage => $_getSZ(4);
  @$pb.TagNumber(5)
  set fixedPackage($core.String value) => $_setString(4, value);
  @$pb.TagNumber(5)
  $core.bool hasFixedPackage() => $_has(4);
  @$pb.TagNumber(5)
  void clearFixedPackage() => $_clearField(5);

  /// Required. The version of the package this vulnerability was fixed in.
  /// Setting this to VersionKind.MAXIMUM means no fix is yet available.
  @$pb.TagNumber(6)
  $2.Version get fixedVersion => $_getN(5);
  @$pb.TagNumber(6)
  set fixedVersion($2.Version value) => $_setField(6, value);
  @$pb.TagNumber(6)
  $core.bool hasFixedVersion() => $_has(5);
  @$pb.TagNumber(6)
  void clearFixedVersion() => $_clearField(6);
  @$pb.TagNumber(6)
  $2.Version ensureFixedVersion() => $_ensure(5);

  /// Output only. Whether a fix is available for this package.
  @$pb.TagNumber(7)
  $core.bool get fixAvailable => $_getBF(6);
  @$pb.TagNumber(7)
  set fixAvailable($core.bool value) => $_setBool(6, value);
  @$pb.TagNumber(7)
  $core.bool hasFixAvailable() => $_has(6);
  @$pb.TagNumber(7)
  void clearFixAvailable() => $_clearField(7);

  /// The type of package (e.g. OS, MAVEN, GO).
  @$pb.TagNumber(8)
  $core.String get packageType => $_getSZ(7);
  @$pb.TagNumber(8)
  set packageType($core.String value) => $_setString(7, value);
  @$pb.TagNumber(8)
  $core.bool hasPackageType() => $_has(7);
  @$pb.TagNumber(8)
  void clearPackageType() => $_clearField(8);

  /// The distro or language system assigned severity for this vulnerability
  /// when that is available and note provider assigned severity when it is not
  /// available.
  @$pb.TagNumber(9)
  $6.Severity get effectiveSeverity => $_getN(8);
  @$pb.TagNumber(9)
  set effectiveSeverity($6.Severity value) => $_setField(9, value);
  @$pb.TagNumber(9)
  $core.bool hasEffectiveSeverity() => $_has(8);
  @$pb.TagNumber(9)
  void clearEffectiveSeverity() => $_clearField(9);

  /// The location at which this package was found.
  @$pb.TagNumber(10)
  $pb.PbList<$3.FileLocation> get fileLocation => $_getList(9);
}

/// VexAssessment provides all publisher provided Vex information that is
/// related to this vulnerability.
class VulnerabilityOccurrence_VexAssessment extends $pb.GeneratedMessage {
  factory VulnerabilityOccurrence_VexAssessment({
    @$core.Deprecated('This field is deprecated.') $core.String? cve,
    $core.Iterable<$3.RelatedUrl>? relatedUris,
    $core.String? noteName,
    $5.VulnerabilityAssessmentNote_Assessment_State? state,
    $core.Iterable<$core.String>? impacts,
    $core.Iterable<$5.VulnerabilityAssessmentNote_Assessment_Remediation>?
        remediations,
    $5.VulnerabilityAssessmentNote_Assessment_Justification? justification,
    $core.String? vulnerabilityId,
  }) {
    final result = create();
    if (cve != null) result.cve = cve;
    if (relatedUris != null) result.relatedUris.addAll(relatedUris);
    if (noteName != null) result.noteName = noteName;
    if (state != null) result.state = state;
    if (impacts != null) result.impacts.addAll(impacts);
    if (remediations != null) result.remediations.addAll(remediations);
    if (justification != null) result.justification = justification;
    if (vulnerabilityId != null) result.vulnerabilityId = vulnerabilityId;
    return result;
  }

  VulnerabilityOccurrence_VexAssessment._();

  factory VulnerabilityOccurrence_VexAssessment.fromBuffer(
          $core.List<$core.int> data,
          [$pb.ExtensionRegistry registry = $pb.ExtensionRegistry.EMPTY]) =>
      create()..mergeFromBuffer(data, registry);
  factory VulnerabilityOccurrence_VexAssessment.fromJson($core.String json,
          [$pb.ExtensionRegistry registry = $pb.ExtensionRegistry.EMPTY]) =>
      create()..mergeFromJson(json, registry);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(
      _omitMessageNames ? '' : 'VulnerabilityOccurrence.VexAssessment',
      package: const $pb.PackageName(_omitMessageNames ? '' : 'grafeas.v1'),
      createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'cve')
    ..pPM<$3.RelatedUrl>(2, _omitFieldNames ? '' : 'relatedUris',
        subBuilder: $3.RelatedUrl.create)
    ..aOS(3, _omitFieldNames ? '' : 'noteName')
    ..aE<$5.VulnerabilityAssessmentNote_Assessment_State>(
        4, _omitFieldNames ? '' : 'state',
        enumValues: $5.VulnerabilityAssessmentNote_Assessment_State.values)
    ..pPS(5, _omitFieldNames ? '' : 'impacts')
    ..pPM<$5.VulnerabilityAssessmentNote_Assessment_Remediation>(
        6, _omitFieldNames ? '' : 'remediations',
        subBuilder:
            $5.VulnerabilityAssessmentNote_Assessment_Remediation.create)
    ..aOM<$5.VulnerabilityAssessmentNote_Assessment_Justification>(
        7, _omitFieldNames ? '' : 'justification',
        subBuilder:
            $5.VulnerabilityAssessmentNote_Assessment_Justification.create)
    ..aOS(8, _omitFieldNames ? '' : 'vulnerabilityId')
    ..hasRequiredFields = false;

  @$core.Deprecated('See https://github.com/google/protobuf.dart/issues/998.')
  VulnerabilityOccurrence_VexAssessment clone() => deepCopy();
  @$core.Deprecated('See https://github.com/google/protobuf.dart/issues/998.')
  VulnerabilityOccurrence_VexAssessment copyWith(
          void Function(VulnerabilityOccurrence_VexAssessment) updates) =>
      super.copyWith((message) =>
              updates(message as VulnerabilityOccurrence_VexAssessment))
          as VulnerabilityOccurrence_VexAssessment;

  @$core.override
  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static VulnerabilityOccurrence_VexAssessment create() =>
      VulnerabilityOccurrence_VexAssessment._();
  @$core.override
  VulnerabilityOccurrence_VexAssessment createEmptyInstance() => create();
  @$core.pragma('dart2js:noInline')
  static VulnerabilityOccurrence_VexAssessment getDefault() =>
      _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<
          VulnerabilityOccurrence_VexAssessment>(create);
  static VulnerabilityOccurrence_VexAssessment? _defaultInstance;

  /// Holds the MITRE standard Common Vulnerabilities and Exposures (CVE)
  /// tracking number for the vulnerability.
  /// Deprecated: Use vulnerability_id instead to denote CVEs.
  @$core.Deprecated('This field is deprecated.')
  @$pb.TagNumber(1)
  $core.String get cve => $_getSZ(0);
  @$core.Deprecated('This field is deprecated.')
  @$pb.TagNumber(1)
  set cve($core.String value) => $_setString(0, value);
  @$core.Deprecated('This field is deprecated.')
  @$pb.TagNumber(1)
  $core.bool hasCve() => $_has(0);
  @$core.Deprecated('This field is deprecated.')
  @$pb.TagNumber(1)
  void clearCve() => $_clearField(1);

  /// Holds a list of references associated with this vulnerability item and
  /// assessment.
  @$pb.TagNumber(2)
  $pb.PbList<$3.RelatedUrl> get relatedUris => $_getList(1);

  /// The VulnerabilityAssessment note from which this VexAssessment was
  /// generated.
  /// This will be of the form: `projects/[PROJECT_ID]/notes/[NOTE_ID]`.
  /// (-- api-linter: core::0122::name-suffix=disabled
  ///     aip.dev/not-precedent: The suffix is kept for consistency. --)
  @$pb.TagNumber(3)
  $core.String get noteName => $_getSZ(2);
  @$pb.TagNumber(3)
  set noteName($core.String value) => $_setString(2, value);
  @$pb.TagNumber(3)
  $core.bool hasNoteName() => $_has(2);
  @$pb.TagNumber(3)
  void clearNoteName() => $_clearField(3);

  /// Provides the state of this Vulnerability assessment.
  @$pb.TagNumber(4)
  $5.VulnerabilityAssessmentNote_Assessment_State get state => $_getN(3);
  @$pb.TagNumber(4)
  set state($5.VulnerabilityAssessmentNote_Assessment_State value) =>
      $_setField(4, value);
  @$pb.TagNumber(4)
  $core.bool hasState() => $_has(3);
  @$pb.TagNumber(4)
  void clearState() => $_clearField(4);

  /// Contains information about the impact of this vulnerability,
  /// this will change with time.
  @$pb.TagNumber(5)
  $pb.PbList<$core.String> get impacts => $_getList(4);

  /// Specifies details on how to handle (and presumably, fix) a vulnerability.
  @$pb.TagNumber(6)
  $pb.PbList<$5.VulnerabilityAssessmentNote_Assessment_Remediation>
      get remediations => $_getList(5);

  /// Justification provides the justification when the state of the
  /// assessment if NOT_AFFECTED.
  @$pb.TagNumber(7)
  $5.VulnerabilityAssessmentNote_Assessment_Justification get justification =>
      $_getN(6);
  @$pb.TagNumber(7)
  set justification(
          $5.VulnerabilityAssessmentNote_Assessment_Justification value) =>
      $_setField(7, value);
  @$pb.TagNumber(7)
  $core.bool hasJustification() => $_has(6);
  @$pb.TagNumber(7)
  void clearJustification() => $_clearField(7);
  @$pb.TagNumber(7)
  $5.VulnerabilityAssessmentNote_Assessment_Justification
      ensureJustification() => $_ensure(6);

  /// The vulnerability identifier for this Assessment. Will hold one of
  /// common identifiers e.g. CVE, GHSA etc.
  @$pb.TagNumber(8)
  $core.String get vulnerabilityId => $_getSZ(7);
  @$pb.TagNumber(8)
  set vulnerabilityId($core.String value) => $_setString(7, value);
  @$pb.TagNumber(8)
  $core.bool hasVulnerabilityId() => $_has(7);
  @$pb.TagNumber(8)
  void clearVulnerabilityId() => $_clearField(8);
}

/// An occurrence of a severity vulnerability on a resource.
class VulnerabilityOccurrence extends $pb.GeneratedMessage {
  factory VulnerabilityOccurrence({
    $core.String? type,
    $6.Severity? severity,
    $core.double? cvssScore,
    $core.Iterable<VulnerabilityOccurrence_PackageIssue>? packageIssue,
    $core.String? shortDescription,
    $core.String? longDescription,
    $core.Iterable<$3.RelatedUrl>? relatedUrls,
    $6.Severity? effectiveSeverity,
    $core.bool? fixAvailable,
    $0.CVSS? cvssv3,
    $0.CVSSVersion? cvssVersion,
    $0.CVSS? cvssV2,
    VulnerabilityOccurrence_VexAssessment? vexAssessment,
    $core.String? extraDetails,
    $4.Risk? risk,
  }) {
    final result = create();
    if (type != null) result.type = type;
    if (severity != null) result.severity = severity;
    if (cvssScore != null) result.cvssScore = cvssScore;
    if (packageIssue != null) result.packageIssue.addAll(packageIssue);
    if (shortDescription != null) result.shortDescription = shortDescription;
    if (longDescription != null) result.longDescription = longDescription;
    if (relatedUrls != null) result.relatedUrls.addAll(relatedUrls);
    if (effectiveSeverity != null) result.effectiveSeverity = effectiveSeverity;
    if (fixAvailable != null) result.fixAvailable = fixAvailable;
    if (cvssv3 != null) result.cvssv3 = cvssv3;
    if (cvssVersion != null) result.cvssVersion = cvssVersion;
    if (cvssV2 != null) result.cvssV2 = cvssV2;
    if (vexAssessment != null) result.vexAssessment = vexAssessment;
    if (extraDetails != null) result.extraDetails = extraDetails;
    if (risk != null) result.risk = risk;
    return result;
  }

  VulnerabilityOccurrence._();

  factory VulnerabilityOccurrence.fromBuffer($core.List<$core.int> data,
          [$pb.ExtensionRegistry registry = $pb.ExtensionRegistry.EMPTY]) =>
      create()..mergeFromBuffer(data, registry);
  factory VulnerabilityOccurrence.fromJson($core.String json,
          [$pb.ExtensionRegistry registry = $pb.ExtensionRegistry.EMPTY]) =>
      create()..mergeFromJson(json, registry);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(
      _omitMessageNames ? '' : 'VulnerabilityOccurrence',
      package: const $pb.PackageName(_omitMessageNames ? '' : 'grafeas.v1'),
      createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'type')
    ..aE<$6.Severity>(2, _omitFieldNames ? '' : 'severity',
        enumValues: $6.Severity.values)
    ..aD(3, _omitFieldNames ? '' : 'cvssScore', fieldType: $pb.PbFieldType.OF)
    ..pPM<VulnerabilityOccurrence_PackageIssue>(
        4, _omitFieldNames ? '' : 'packageIssue',
        subBuilder: VulnerabilityOccurrence_PackageIssue.create)
    ..aOS(5, _omitFieldNames ? '' : 'shortDescription')
    ..aOS(6, _omitFieldNames ? '' : 'longDescription')
    ..pPM<$3.RelatedUrl>(7, _omitFieldNames ? '' : 'relatedUrls',
        subBuilder: $3.RelatedUrl.create)
    ..aE<$6.Severity>(8, _omitFieldNames ? '' : 'effectiveSeverity',
        enumValues: $6.Severity.values)
    ..aOB(9, _omitFieldNames ? '' : 'fixAvailable')
    ..aOM<$0.CVSS>(10, _omitFieldNames ? '' : 'cvssv3',
        subBuilder: $0.CVSS.create)
    ..aE<$0.CVSSVersion>(11, _omitFieldNames ? '' : 'cvssVersion',
        enumValues: $0.CVSSVersion.values)
    ..aOM<$0.CVSS>(12, _omitFieldNames ? '' : 'cvssV2',
        subBuilder: $0.CVSS.create)
    ..aOM<VulnerabilityOccurrence_VexAssessment>(
        13, _omitFieldNames ? '' : 'vexAssessment',
        subBuilder: VulnerabilityOccurrence_VexAssessment.create)
    ..aOS(14, _omitFieldNames ? '' : 'extraDetails')
    ..aOM<$4.Risk>(15, _omitFieldNames ? '' : 'risk',
        subBuilder: $4.Risk.create)
    ..hasRequiredFields = false;

  @$core.Deprecated('See https://github.com/google/protobuf.dart/issues/998.')
  VulnerabilityOccurrence clone() => deepCopy();
  @$core.Deprecated('See https://github.com/google/protobuf.dart/issues/998.')
  VulnerabilityOccurrence copyWith(
          void Function(VulnerabilityOccurrence) updates) =>
      super.copyWith((message) => updates(message as VulnerabilityOccurrence))
          as VulnerabilityOccurrence;

  @$core.override
  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static VulnerabilityOccurrence create() => VulnerabilityOccurrence._();
  @$core.override
  VulnerabilityOccurrence createEmptyInstance() => create();
  @$core.pragma('dart2js:noInline')
  static VulnerabilityOccurrence getDefault() => _defaultInstance ??=
      $pb.GeneratedMessage.$_defaultFor<VulnerabilityOccurrence>(create);
  static VulnerabilityOccurrence? _defaultInstance;

  /// The type of package; whether native or non native (e.g., ruby gems, node.js
  /// packages, etc.).
  @$pb.TagNumber(1)
  $core.String get type => $_getSZ(0);
  @$pb.TagNumber(1)
  set type($core.String value) => $_setString(0, value);
  @$pb.TagNumber(1)
  $core.bool hasType() => $_has(0);
  @$pb.TagNumber(1)
  void clearType() => $_clearField(1);

  /// Output only. The note provider assigned severity of this vulnerability.
  @$pb.TagNumber(2)
  $6.Severity get severity => $_getN(1);
  @$pb.TagNumber(2)
  set severity($6.Severity value) => $_setField(2, value);
  @$pb.TagNumber(2)
  $core.bool hasSeverity() => $_has(1);
  @$pb.TagNumber(2)
  void clearSeverity() => $_clearField(2);

  /// Output only. The CVSS score of this vulnerability. CVSS score is on a
  /// scale of 0 - 10 where 0 indicates low severity and 10 indicates high
  /// severity.
  @$pb.TagNumber(3)
  $core.double get cvssScore => $_getN(2);
  @$pb.TagNumber(3)
  set cvssScore($core.double value) => $_setFloat(2, value);
  @$pb.TagNumber(3)
  $core.bool hasCvssScore() => $_has(2);
  @$pb.TagNumber(3)
  void clearCvssScore() => $_clearField(3);

  /// Required. The set of affected locations and their fixes (if available)
  /// within the associated resource.
  @$pb.TagNumber(4)
  $pb.PbList<VulnerabilityOccurrence_PackageIssue> get packageIssue =>
      $_getList(3);

  /// Output only. A one sentence description of this vulnerability.
  @$pb.TagNumber(5)
  $core.String get shortDescription => $_getSZ(4);
  @$pb.TagNumber(5)
  set shortDescription($core.String value) => $_setString(4, value);
  @$pb.TagNumber(5)
  $core.bool hasShortDescription() => $_has(4);
  @$pb.TagNumber(5)
  void clearShortDescription() => $_clearField(5);

  /// Output only. A detailed description of this vulnerability.
  @$pb.TagNumber(6)
  $core.String get longDescription => $_getSZ(5);
  @$pb.TagNumber(6)
  set longDescription($core.String value) => $_setString(5, value);
  @$pb.TagNumber(6)
  $core.bool hasLongDescription() => $_has(5);
  @$pb.TagNumber(6)
  void clearLongDescription() => $_clearField(6);

  /// Output only. URLs related to this vulnerability.
  @$pb.TagNumber(7)
  $pb.PbList<$3.RelatedUrl> get relatedUrls => $_getList(6);

  /// The distro assigned severity for this vulnerability when it is available,
  /// otherwise this is the note provider assigned severity.
  ///
  /// When there are multiple PackageIssues for this vulnerability, they can have
  /// different effective severities because some might be provided by the distro
  /// while others are provided by the language ecosystem for a language pack.
  /// For this reason, it is advised to use the effective severity on the
  /// PackageIssue level. In the case where multiple PackageIssues have differing
  /// effective severities, this field should be the highest severity for any of
  /// the PackageIssues.
  @$pb.TagNumber(8)
  $6.Severity get effectiveSeverity => $_getN(7);
  @$pb.TagNumber(8)
  set effectiveSeverity($6.Severity value) => $_setField(8, value);
  @$pb.TagNumber(8)
  $core.bool hasEffectiveSeverity() => $_has(7);
  @$pb.TagNumber(8)
  void clearEffectiveSeverity() => $_clearField(8);

  /// Output only. Whether at least one of the affected packages has a fix
  /// available.
  @$pb.TagNumber(9)
  $core.bool get fixAvailable => $_getBF(8);
  @$pb.TagNumber(9)
  set fixAvailable($core.bool value) => $_setBool(8, value);
  @$pb.TagNumber(9)
  $core.bool hasFixAvailable() => $_has(8);
  @$pb.TagNumber(9)
  void clearFixAvailable() => $_clearField(9);

  /// The cvss v3 score for the vulnerability.
  @$pb.TagNumber(10)
  $0.CVSS get cvssv3 => $_getN(9);
  @$pb.TagNumber(10)
  set cvssv3($0.CVSS value) => $_setField(10, value);
  @$pb.TagNumber(10)
  $core.bool hasCvssv3() => $_has(9);
  @$pb.TagNumber(10)
  void clearCvssv3() => $_clearField(10);
  @$pb.TagNumber(10)
  $0.CVSS ensureCvssv3() => $_ensure(9);

  /// Output only. CVSS version used to populate cvss_score and severity.
  @$pb.TagNumber(11)
  $0.CVSSVersion get cvssVersion => $_getN(10);
  @$pb.TagNumber(11)
  set cvssVersion($0.CVSSVersion value) => $_setField(11, value);
  @$pb.TagNumber(11)
  $core.bool hasCvssVersion() => $_has(10);
  @$pb.TagNumber(11)
  void clearCvssVersion() => $_clearField(11);

  /// The cvss v2 score for the vulnerability.
  @$pb.TagNumber(12)
  $0.CVSS get cvssV2 => $_getN(11);
  @$pb.TagNumber(12)
  set cvssV2($0.CVSS value) => $_setField(12, value);
  @$pb.TagNumber(12)
  $core.bool hasCvssV2() => $_has(11);
  @$pb.TagNumber(12)
  void clearCvssV2() => $_clearField(12);
  @$pb.TagNumber(12)
  $0.CVSS ensureCvssV2() => $_ensure(11);

  @$pb.TagNumber(13)
  VulnerabilityOccurrence_VexAssessment get vexAssessment => $_getN(12);
  @$pb.TagNumber(13)
  set vexAssessment(VulnerabilityOccurrence_VexAssessment value) =>
      $_setField(13, value);
  @$pb.TagNumber(13)
  $core.bool hasVexAssessment() => $_has(12);
  @$pb.TagNumber(13)
  void clearVexAssessment() => $_clearField(13);
  @$pb.TagNumber(13)
  VulnerabilityOccurrence_VexAssessment ensureVexAssessment() => $_ensure(12);

  /// Occurrence-specific extra details about the vulnerability.
  @$pb.TagNumber(14)
  $core.String get extraDetails => $_getSZ(13);
  @$pb.TagNumber(14)
  set extraDetails($core.String value) => $_setString(13, value);
  @$pb.TagNumber(14)
  $core.bool hasExtraDetails() => $_has(13);
  @$pb.TagNumber(14)
  void clearExtraDetails() => $_clearField(14);

  /// Risk information about the vulnerability, such as CISA, EPSS, etc.
  @$pb.TagNumber(15)
  $4.Risk get risk => $_getN(14);
  @$pb.TagNumber(15)
  set risk($4.Risk value) => $_setField(15, value);
  @$pb.TagNumber(15)
  $core.bool hasRisk() => $_has(14);
  @$pb.TagNumber(15)
  void clearRisk() => $_clearField(15);
  @$pb.TagNumber(15)
  $4.Risk ensureRisk() => $_ensure(14);
}

const $core.bool _omitFieldNames =
    $core.bool.fromEnvironment('protobuf.omit_field_names');
const $core.bool _omitMessageNames =
    $core.bool.fromEnvironment('protobuf.omit_message_names');
