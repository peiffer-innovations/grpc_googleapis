//
//  Generated code. Do not modify.
//  source: grafeas/v1/vulnerability.proto
//
// @dart = 2.12

// ignore_for_file: annotate_overrides, camel_case_types, comment_references
// ignore_for_file: constant_identifier_names, library_prefixes
// ignore_for_file: non_constant_identifier_names, prefer_final_fields
// ignore_for_file: unnecessary_import, unnecessary_this, unused_import

import 'dart:core' as $core;

import 'package:protobuf/protobuf.dart' as $pb;

import '../../google/protobuf/timestamp.pb.dart' as $1;
import 'common.pb.dart' as $3;
import 'cvss.pb.dart' as $0;
import 'cvss.pbenum.dart' as $0;
import 'package.pb.dart' as $2;
import 'severity.pbenum.dart' as $5;
import 'vex.pb.dart' as $4;
import 'vex.pbenum.dart' as $4;

/// A detail for a distro and package affected by this vulnerability and its
/// associated fix (if one is available).
class VulnerabilityNote_Detail extends $pb.GeneratedMessage {
  factory VulnerabilityNote_Detail({
    $core.String? severityName,
    $core.String? description,
    $core.String? packageType,
    $core.String? affectedCpeUri,
    $core.String? affectedPackage,
    $2.Version? affectedVersionStart,
    $2.Version? affectedVersionEnd,
    $core.String? fixedCpeUri,
    $core.String? fixedPackage,
    $2.Version? fixedVersion,
    $core.bool? isObsolete,
    $1.Timestamp? sourceUpdateTime,
    $core.String? source,
    $core.String? vendor,
  }) {
    final $result = create();
    if (severityName != null) {
      $result.severityName = severityName;
    }
    if (description != null) {
      $result.description = description;
    }
    if (packageType != null) {
      $result.packageType = packageType;
    }
    if (affectedCpeUri != null) {
      $result.affectedCpeUri = affectedCpeUri;
    }
    if (affectedPackage != null) {
      $result.affectedPackage = affectedPackage;
    }
    if (affectedVersionStart != null) {
      $result.affectedVersionStart = affectedVersionStart;
    }
    if (affectedVersionEnd != null) {
      $result.affectedVersionEnd = affectedVersionEnd;
    }
    if (fixedCpeUri != null) {
      $result.fixedCpeUri = fixedCpeUri;
    }
    if (fixedPackage != null) {
      $result.fixedPackage = fixedPackage;
    }
    if (fixedVersion != null) {
      $result.fixedVersion = fixedVersion;
    }
    if (isObsolete != null) {
      $result.isObsolete = isObsolete;
    }
    if (sourceUpdateTime != null) {
      $result.sourceUpdateTime = sourceUpdateTime;
    }
    if (source != null) {
      $result.source = source;
    }
    if (vendor != null) {
      $result.vendor = vendor;
    }
    return $result;
  }
  VulnerabilityNote_Detail._() : super();
  factory VulnerabilityNote_Detail.fromBuffer($core.List<$core.int> i,
          [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) =>
      create()..mergeFromBuffer(i, r);
  factory VulnerabilityNote_Detail.fromJson($core.String i,
          [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) =>
      create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(
      _omitMessageNames ? '' : 'VulnerabilityNote.Detail',
      package: const $pb.PackageName(_omitMessageNames ? '' : 'grafeas.v1'),
      createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'severityName')
    ..aOS(2, _omitFieldNames ? '' : 'description')
    ..aOS(3, _omitFieldNames ? '' : 'packageType')
    ..aOS(4, _omitFieldNames ? '' : 'affectedCpeUri')
    ..aOS(5, _omitFieldNames ? '' : 'affectedPackage')
    ..aOM<$2.Version>(6, _omitFieldNames ? '' : 'affectedVersionStart',
        subBuilder: $2.Version.create)
    ..aOM<$2.Version>(7, _omitFieldNames ? '' : 'affectedVersionEnd',
        subBuilder: $2.Version.create)
    ..aOS(8, _omitFieldNames ? '' : 'fixedCpeUri')
    ..aOS(9, _omitFieldNames ? '' : 'fixedPackage')
    ..aOM<$2.Version>(10, _omitFieldNames ? '' : 'fixedVersion',
        subBuilder: $2.Version.create)
    ..aOB(11, _omitFieldNames ? '' : 'isObsolete')
    ..aOM<$1.Timestamp>(12, _omitFieldNames ? '' : 'sourceUpdateTime',
        subBuilder: $1.Timestamp.create)
    ..aOS(13, _omitFieldNames ? '' : 'source')
    ..aOS(14, _omitFieldNames ? '' : 'vendor')
    ..hasRequiredFields = false;

  @$core.Deprecated('Using this can add significant overhead to your binary. '
      'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
      'Will be removed in next major version')
  VulnerabilityNote_Detail clone() =>
      VulnerabilityNote_Detail()..mergeFromMessage(this);
  @$core.Deprecated('Using this can add significant overhead to your binary. '
      'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
      'Will be removed in next major version')
  VulnerabilityNote_Detail copyWith(
          void Function(VulnerabilityNote_Detail) updates) =>
      super.copyWith((message) => updates(message as VulnerabilityNote_Detail))
          as VulnerabilityNote_Detail;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static VulnerabilityNote_Detail create() => VulnerabilityNote_Detail._();
  VulnerabilityNote_Detail createEmptyInstance() => create();
  static $pb.PbList<VulnerabilityNote_Detail> createRepeated() =>
      $pb.PbList<VulnerabilityNote_Detail>();
  @$core.pragma('dart2js:noInline')
  static VulnerabilityNote_Detail getDefault() => _defaultInstance ??=
      $pb.GeneratedMessage.$_defaultFor<VulnerabilityNote_Detail>(create);
  static VulnerabilityNote_Detail? _defaultInstance;

  /// The distro assigned severity of this vulnerability.
  @$pb.TagNumber(1)
  $core.String get severityName => $_getSZ(0);
  @$pb.TagNumber(1)
  set severityName($core.String v) {
    $_setString(0, v);
  }

  @$pb.TagNumber(1)
  $core.bool hasSeverityName() => $_has(0);
  @$pb.TagNumber(1)
  void clearSeverityName() => clearField(1);

  /// A vendor-specific description of this vulnerability.
  @$pb.TagNumber(2)
  $core.String get description => $_getSZ(1);
  @$pb.TagNumber(2)
  set description($core.String v) {
    $_setString(1, v);
  }

  @$pb.TagNumber(2)
  $core.bool hasDescription() => $_has(1);
  @$pb.TagNumber(2)
  void clearDescription() => clearField(2);

  /// The type of package; whether native or non native (e.g., ruby gems,
  /// node.js packages, etc.).
  @$pb.TagNumber(3)
  $core.String get packageType => $_getSZ(2);
  @$pb.TagNumber(3)
  set packageType($core.String v) {
    $_setString(2, v);
  }

  @$pb.TagNumber(3)
  $core.bool hasPackageType() => $_has(2);
  @$pb.TagNumber(3)
  void clearPackageType() => clearField(3);

  /// Required. The [CPE URI](https://cpe.mitre.org/specification/) this
  /// vulnerability affects.
  @$pb.TagNumber(4)
  $core.String get affectedCpeUri => $_getSZ(3);
  @$pb.TagNumber(4)
  set affectedCpeUri($core.String v) {
    $_setString(3, v);
  }

  @$pb.TagNumber(4)
  $core.bool hasAffectedCpeUri() => $_has(3);
  @$pb.TagNumber(4)
  void clearAffectedCpeUri() => clearField(4);

  /// Required. The package this vulnerability affects.
  @$pb.TagNumber(5)
  $core.String get affectedPackage => $_getSZ(4);
  @$pb.TagNumber(5)
  set affectedPackage($core.String v) {
    $_setString(4, v);
  }

  @$pb.TagNumber(5)
  $core.bool hasAffectedPackage() => $_has(4);
  @$pb.TagNumber(5)
  void clearAffectedPackage() => clearField(5);

  /// The version number at the start of an interval in which this vulnerability
  /// exists. A vulnerability can affect a package between version numbers
  /// that are disjoint sets of intervals (example: [1.0.0-1.1.0], [2.4.6-2.4.8]
  /// and [4.5.6-4.6.8]) each of which will be represented in its own Detail.
  /// If a specific affected version is provided by a vulnerability database,
  /// affected_version_start and affected_version_end will be the same in that
  /// Detail.
  @$pb.TagNumber(6)
  $2.Version get affectedVersionStart => $_getN(5);
  @$pb.TagNumber(6)
  set affectedVersionStart($2.Version v) {
    setField(6, v);
  }

  @$pb.TagNumber(6)
  $core.bool hasAffectedVersionStart() => $_has(5);
  @$pb.TagNumber(6)
  void clearAffectedVersionStart() => clearField(6);
  @$pb.TagNumber(6)
  $2.Version ensureAffectedVersionStart() => $_ensure(5);

  /// The version number at the end of an interval in which this vulnerability
  /// exists. A vulnerability can affect a package between version numbers
  /// that are disjoint sets of intervals (example: [1.0.0-1.1.0], [2.4.6-2.4.8]
  /// and [4.5.6-4.6.8]) each of which will be represented in its own Detail.
  /// If a specific affected version is provided by a vulnerability database,
  /// affected_version_start and affected_version_end will be the same in that
  /// Detail.
  @$pb.TagNumber(7)
  $2.Version get affectedVersionEnd => $_getN(6);
  @$pb.TagNumber(7)
  set affectedVersionEnd($2.Version v) {
    setField(7, v);
  }

  @$pb.TagNumber(7)
  $core.bool hasAffectedVersionEnd() => $_has(6);
  @$pb.TagNumber(7)
  void clearAffectedVersionEnd() => clearField(7);
  @$pb.TagNumber(7)
  $2.Version ensureAffectedVersionEnd() => $_ensure(6);

  /// The distro recommended [CPE URI](https://cpe.mitre.org/specification/)
  /// to update to that contains a fix for this vulnerability. It is possible
  /// for this to be different from the affected_cpe_uri.
  @$pb.TagNumber(8)
  $core.String get fixedCpeUri => $_getSZ(7);
  @$pb.TagNumber(8)
  set fixedCpeUri($core.String v) {
    $_setString(7, v);
  }

  @$pb.TagNumber(8)
  $core.bool hasFixedCpeUri() => $_has(7);
  @$pb.TagNumber(8)
  void clearFixedCpeUri() => clearField(8);

  /// The distro recommended package to update to that contains a fix for this
  /// vulnerability. It is possible for this to be different from the affected_package.
  @$pb.TagNumber(9)
  $core.String get fixedPackage => $_getSZ(8);
  @$pb.TagNumber(9)
  set fixedPackage($core.String v) {
    $_setString(8, v);
  }

  @$pb.TagNumber(9)
  $core.bool hasFixedPackage() => $_has(8);
  @$pb.TagNumber(9)
  void clearFixedPackage() => clearField(9);

  /// The distro recommended version to update to that contains a
  /// fix for this vulnerability. Setting this to VersionKind.MAXIMUM means no
  /// such version is yet available.
  @$pb.TagNumber(10)
  $2.Version get fixedVersion => $_getN(9);
  @$pb.TagNumber(10)
  set fixedVersion($2.Version v) {
    setField(10, v);
  }

  @$pb.TagNumber(10)
  $core.bool hasFixedVersion() => $_has(9);
  @$pb.TagNumber(10)
  void clearFixedVersion() => clearField(10);
  @$pb.TagNumber(10)
  $2.Version ensureFixedVersion() => $_ensure(9);

  /// Whether this detail is obsolete. Occurrences are expected not to point to
  /// obsolete details.
  @$pb.TagNumber(11)
  $core.bool get isObsolete => $_getBF(10);
  @$pb.TagNumber(11)
  set isObsolete($core.bool v) {
    $_setBool(10, v);
  }

  @$pb.TagNumber(11)
  $core.bool hasIsObsolete() => $_has(10);
  @$pb.TagNumber(11)
  void clearIsObsolete() => clearField(11);

  /// The time this information was last changed at the source. This is an
  /// upstream timestamp from the underlying information source - e.g. Ubuntu
  /// security tracker.
  @$pb.TagNumber(12)
  $1.Timestamp get sourceUpdateTime => $_getN(11);
  @$pb.TagNumber(12)
  set sourceUpdateTime($1.Timestamp v) {
    setField(12, v);
  }

  @$pb.TagNumber(12)
  $core.bool hasSourceUpdateTime() => $_has(11);
  @$pb.TagNumber(12)
  void clearSourceUpdateTime() => clearField(12);
  @$pb.TagNumber(12)
  $1.Timestamp ensureSourceUpdateTime() => $_ensure(11);

  /// The source from which the information in this Detail was obtained.
  @$pb.TagNumber(13)
  $core.String get source => $_getSZ(12);
  @$pb.TagNumber(13)
  set source($core.String v) {
    $_setString(12, v);
  }

  @$pb.TagNumber(13)
  $core.bool hasSource() => $_has(12);
  @$pb.TagNumber(13)
  void clearSource() => clearField(13);

  /// The name of the vendor of the product.
  @$pb.TagNumber(14)
  $core.String get vendor => $_getSZ(13);
  @$pb.TagNumber(14)
  set vendor($core.String v) {
    $_setString(13, v);
  }

  @$pb.TagNumber(14)
  $core.bool hasVendor() => $_has(13);
  @$pb.TagNumber(14)
  void clearVendor() => clearField(14);
}

class VulnerabilityNote_WindowsDetail_KnowledgeBase
    extends $pb.GeneratedMessage {
  factory VulnerabilityNote_WindowsDetail_KnowledgeBase({
    $core.String? name,
    $core.String? url,
  }) {
    final $result = create();
    if (name != null) {
      $result.name = name;
    }
    if (url != null) {
      $result.url = url;
    }
    return $result;
  }
  VulnerabilityNote_WindowsDetail_KnowledgeBase._() : super();
  factory VulnerabilityNote_WindowsDetail_KnowledgeBase.fromBuffer(
          $core.List<$core.int> i,
          [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) =>
      create()..mergeFromBuffer(i, r);
  factory VulnerabilityNote_WindowsDetail_KnowledgeBase.fromJson($core.String i,
          [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) =>
      create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(
      _omitMessageNames ? '' : 'VulnerabilityNote.WindowsDetail.KnowledgeBase',
      package: const $pb.PackageName(_omitMessageNames ? '' : 'grafeas.v1'),
      createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'name')
    ..aOS(2, _omitFieldNames ? '' : 'url')
    ..hasRequiredFields = false;

  @$core.Deprecated('Using this can add significant overhead to your binary. '
      'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
      'Will be removed in next major version')
  VulnerabilityNote_WindowsDetail_KnowledgeBase clone() =>
      VulnerabilityNote_WindowsDetail_KnowledgeBase()..mergeFromMessage(this);
  @$core.Deprecated('Using this can add significant overhead to your binary. '
      'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
      'Will be removed in next major version')
  VulnerabilityNote_WindowsDetail_KnowledgeBase copyWith(
          void Function(VulnerabilityNote_WindowsDetail_KnowledgeBase)
              updates) =>
      super.copyWith((message) =>
              updates(message as VulnerabilityNote_WindowsDetail_KnowledgeBase))
          as VulnerabilityNote_WindowsDetail_KnowledgeBase;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static VulnerabilityNote_WindowsDetail_KnowledgeBase create() =>
      VulnerabilityNote_WindowsDetail_KnowledgeBase._();
  VulnerabilityNote_WindowsDetail_KnowledgeBase createEmptyInstance() =>
      create();
  static $pb.PbList<VulnerabilityNote_WindowsDetail_KnowledgeBase>
      createRepeated() =>
          $pb.PbList<VulnerabilityNote_WindowsDetail_KnowledgeBase>();
  @$core.pragma('dart2js:noInline')
  static VulnerabilityNote_WindowsDetail_KnowledgeBase getDefault() =>
      _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<
          VulnerabilityNote_WindowsDetail_KnowledgeBase>(create);
  static VulnerabilityNote_WindowsDetail_KnowledgeBase? _defaultInstance;

  /// The KB name (generally of the form KB[0-9]+ (e.g., KB123456)).
  @$pb.TagNumber(1)
  $core.String get name => $_getSZ(0);
  @$pb.TagNumber(1)
  set name($core.String v) {
    $_setString(0, v);
  }

  @$pb.TagNumber(1)
  $core.bool hasName() => $_has(0);
  @$pb.TagNumber(1)
  void clearName() => clearField(1);

  /// A link to the KB in the [Windows update catalog]
  /// (https://www.catalog.update.microsoft.com/).
  @$pb.TagNumber(2)
  $core.String get url => $_getSZ(1);
  @$pb.TagNumber(2)
  set url($core.String v) {
    $_setString(1, v);
  }

  @$pb.TagNumber(2)
  $core.bool hasUrl() => $_has(1);
  @$pb.TagNumber(2)
  void clearUrl() => clearField(2);
}

class VulnerabilityNote_WindowsDetail extends $pb.GeneratedMessage {
  factory VulnerabilityNote_WindowsDetail({
    $core.String? cpeUri,
    $core.String? name,
    $core.String? description,
    $core.Iterable<VulnerabilityNote_WindowsDetail_KnowledgeBase>? fixingKbs,
  }) {
    final $result = create();
    if (cpeUri != null) {
      $result.cpeUri = cpeUri;
    }
    if (name != null) {
      $result.name = name;
    }
    if (description != null) {
      $result.description = description;
    }
    if (fixingKbs != null) {
      $result.fixingKbs.addAll(fixingKbs);
    }
    return $result;
  }
  VulnerabilityNote_WindowsDetail._() : super();
  factory VulnerabilityNote_WindowsDetail.fromBuffer($core.List<$core.int> i,
          [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) =>
      create()..mergeFromBuffer(i, r);
  factory VulnerabilityNote_WindowsDetail.fromJson($core.String i,
          [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) =>
      create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(
      _omitMessageNames ? '' : 'VulnerabilityNote.WindowsDetail',
      package: const $pb.PackageName(_omitMessageNames ? '' : 'grafeas.v1'),
      createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'cpeUri')
    ..aOS(2, _omitFieldNames ? '' : 'name')
    ..aOS(3, _omitFieldNames ? '' : 'description')
    ..pc<VulnerabilityNote_WindowsDetail_KnowledgeBase>(
        4, _omitFieldNames ? '' : 'fixingKbs', $pb.PbFieldType.PM,
        subBuilder: VulnerabilityNote_WindowsDetail_KnowledgeBase.create)
    ..hasRequiredFields = false;

  @$core.Deprecated('Using this can add significant overhead to your binary. '
      'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
      'Will be removed in next major version')
  VulnerabilityNote_WindowsDetail clone() =>
      VulnerabilityNote_WindowsDetail()..mergeFromMessage(this);
  @$core.Deprecated('Using this can add significant overhead to your binary. '
      'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
      'Will be removed in next major version')
  VulnerabilityNote_WindowsDetail copyWith(
          void Function(VulnerabilityNote_WindowsDetail) updates) =>
      super.copyWith(
              (message) => updates(message as VulnerabilityNote_WindowsDetail))
          as VulnerabilityNote_WindowsDetail;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static VulnerabilityNote_WindowsDetail create() =>
      VulnerabilityNote_WindowsDetail._();
  VulnerabilityNote_WindowsDetail createEmptyInstance() => create();
  static $pb.PbList<VulnerabilityNote_WindowsDetail> createRepeated() =>
      $pb.PbList<VulnerabilityNote_WindowsDetail>();
  @$core.pragma('dart2js:noInline')
  static VulnerabilityNote_WindowsDetail getDefault() => _defaultInstance ??=
      $pb.GeneratedMessage.$_defaultFor<VulnerabilityNote_WindowsDetail>(
          create);
  static VulnerabilityNote_WindowsDetail? _defaultInstance;

  /// Required. The [CPE URI](https://cpe.mitre.org/specification/) this
  /// vulnerability affects.
  @$pb.TagNumber(1)
  $core.String get cpeUri => $_getSZ(0);
  @$pb.TagNumber(1)
  set cpeUri($core.String v) {
    $_setString(0, v);
  }

  @$pb.TagNumber(1)
  $core.bool hasCpeUri() => $_has(0);
  @$pb.TagNumber(1)
  void clearCpeUri() => clearField(1);

  /// Required. The name of this vulnerability.
  @$pb.TagNumber(2)
  $core.String get name => $_getSZ(1);
  @$pb.TagNumber(2)
  set name($core.String v) {
    $_setString(1, v);
  }

  @$pb.TagNumber(2)
  $core.bool hasName() => $_has(1);
  @$pb.TagNumber(2)
  void clearName() => clearField(2);

  /// The description of this vulnerability.
  @$pb.TagNumber(3)
  $core.String get description => $_getSZ(2);
  @$pb.TagNumber(3)
  set description($core.String v) {
    $_setString(2, v);
  }

  @$pb.TagNumber(3)
  $core.bool hasDescription() => $_has(2);
  @$pb.TagNumber(3)
  void clearDescription() => clearField(3);

  /// Required. The names of the KBs which have hotfixes to mitigate this
  /// vulnerability. Note that there may be multiple hotfixes (and thus
  /// multiple KBs) that mitigate a given vulnerability. Currently any listed
  /// KBs presence is considered a fix.
  @$pb.TagNumber(4)
  $core.List<VulnerabilityNote_WindowsDetail_KnowledgeBase> get fixingKbs =>
      $_getList(3);
}

/// A security vulnerability that can be found in resources.
class VulnerabilityNote extends $pb.GeneratedMessage {
  factory VulnerabilityNote({
    $core.double? cvssScore,
    $5.Severity? severity,
    $core.Iterable<VulnerabilityNote_Detail>? details,
    $0.CVSSv3? cvssV3,
    $core.Iterable<VulnerabilityNote_WindowsDetail>? windowsDetails,
    $1.Timestamp? sourceUpdateTime,
    $0.CVSSVersion? cvssVersion,
    $0.CVSS? cvssV2,
  }) {
    final $result = create();
    if (cvssScore != null) {
      $result.cvssScore = cvssScore;
    }
    if (severity != null) {
      $result.severity = severity;
    }
    if (details != null) {
      $result.details.addAll(details);
    }
    if (cvssV3 != null) {
      $result.cvssV3 = cvssV3;
    }
    if (windowsDetails != null) {
      $result.windowsDetails.addAll(windowsDetails);
    }
    if (sourceUpdateTime != null) {
      $result.sourceUpdateTime = sourceUpdateTime;
    }
    if (cvssVersion != null) {
      $result.cvssVersion = cvssVersion;
    }
    if (cvssV2 != null) {
      $result.cvssV2 = cvssV2;
    }
    return $result;
  }
  VulnerabilityNote._() : super();
  factory VulnerabilityNote.fromBuffer($core.List<$core.int> i,
          [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) =>
      create()..mergeFromBuffer(i, r);
  factory VulnerabilityNote.fromJson($core.String i,
          [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) =>
      create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(
      _omitMessageNames ? '' : 'VulnerabilityNote',
      package: const $pb.PackageName(_omitMessageNames ? '' : 'grafeas.v1'),
      createEmptyInstance: create)
    ..a<$core.double>(1, _omitFieldNames ? '' : 'cvssScore', $pb.PbFieldType.OF)
    ..e<$5.Severity>(2, _omitFieldNames ? '' : 'severity', $pb.PbFieldType.OE,
        defaultOrMaker: $5.Severity.SEVERITY_UNSPECIFIED,
        valueOf: $5.Severity.valueOf,
        enumValues: $5.Severity.values)
    ..pc<VulnerabilityNote_Detail>(
        3, _omitFieldNames ? '' : 'details', $pb.PbFieldType.PM,
        subBuilder: VulnerabilityNote_Detail.create)
    ..aOM<$0.CVSSv3>(4, _omitFieldNames ? '' : 'cvssV3',
        subBuilder: $0.CVSSv3.create)
    ..pc<VulnerabilityNote_WindowsDetail>(
        5, _omitFieldNames ? '' : 'windowsDetails', $pb.PbFieldType.PM,
        subBuilder: VulnerabilityNote_WindowsDetail.create)
    ..aOM<$1.Timestamp>(6, _omitFieldNames ? '' : 'sourceUpdateTime',
        subBuilder: $1.Timestamp.create)
    ..e<$0.CVSSVersion>(
        7, _omitFieldNames ? '' : 'cvssVersion', $pb.PbFieldType.OE,
        defaultOrMaker: $0.CVSSVersion.CVSS_VERSION_UNSPECIFIED,
        valueOf: $0.CVSSVersion.valueOf,
        enumValues: $0.CVSSVersion.values)
    ..aOM<$0.CVSS>(8, _omitFieldNames ? '' : 'cvssV2',
        subBuilder: $0.CVSS.create)
    ..hasRequiredFields = false;

  @$core.Deprecated('Using this can add significant overhead to your binary. '
      'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
      'Will be removed in next major version')
  VulnerabilityNote clone() => VulnerabilityNote()..mergeFromMessage(this);
  @$core.Deprecated('Using this can add significant overhead to your binary. '
      'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
      'Will be removed in next major version')
  VulnerabilityNote copyWith(void Function(VulnerabilityNote) updates) =>
      super.copyWith((message) => updates(message as VulnerabilityNote))
          as VulnerabilityNote;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static VulnerabilityNote create() => VulnerabilityNote._();
  VulnerabilityNote createEmptyInstance() => create();
  static $pb.PbList<VulnerabilityNote> createRepeated() =>
      $pb.PbList<VulnerabilityNote>();
  @$core.pragma('dart2js:noInline')
  static VulnerabilityNote getDefault() => _defaultInstance ??=
      $pb.GeneratedMessage.$_defaultFor<VulnerabilityNote>(create);
  static VulnerabilityNote? _defaultInstance;

  /// The CVSS score of this vulnerability. CVSS score is on a scale of 0 - 10
  /// where 0 indicates low severity and 10 indicates high severity.
  @$pb.TagNumber(1)
  $core.double get cvssScore => $_getN(0);
  @$pb.TagNumber(1)
  set cvssScore($core.double v) {
    $_setFloat(0, v);
  }

  @$pb.TagNumber(1)
  $core.bool hasCvssScore() => $_has(0);
  @$pb.TagNumber(1)
  void clearCvssScore() => clearField(1);

  /// The note provider assigned severity of this vulnerability.
  @$pb.TagNumber(2)
  $5.Severity get severity => $_getN(1);
  @$pb.TagNumber(2)
  set severity($5.Severity v) {
    setField(2, v);
  }

  @$pb.TagNumber(2)
  $core.bool hasSeverity() => $_has(1);
  @$pb.TagNumber(2)
  void clearSeverity() => clearField(2);

  /// Details of all known distros and packages affected by this vulnerability.
  @$pb.TagNumber(3)
  $core.List<VulnerabilityNote_Detail> get details => $_getList(2);

  /// The full description of the CVSSv3 for this vulnerability.
  @$pb.TagNumber(4)
  $0.CVSSv3 get cvssV3 => $_getN(3);
  @$pb.TagNumber(4)
  set cvssV3($0.CVSSv3 v) {
    setField(4, v);
  }

  @$pb.TagNumber(4)
  $core.bool hasCvssV3() => $_has(3);
  @$pb.TagNumber(4)
  void clearCvssV3() => clearField(4);
  @$pb.TagNumber(4)
  $0.CVSSv3 ensureCvssV3() => $_ensure(3);

  /// Windows details get their own format because the information format and
  /// model don't match a normal detail. Specifically Windows updates are done as
  /// patches, thus Windows vulnerabilities really are a missing package, rather
  /// than a package being at an incorrect version.
  @$pb.TagNumber(5)
  $core.List<VulnerabilityNote_WindowsDetail> get windowsDetails =>
      $_getList(4);

  /// The time this information was last changed at the source. This is an
  /// upstream timestamp from the underlying information source - e.g. Ubuntu
  /// security tracker.
  @$pb.TagNumber(6)
  $1.Timestamp get sourceUpdateTime => $_getN(5);
  @$pb.TagNumber(6)
  set sourceUpdateTime($1.Timestamp v) {
    setField(6, v);
  }

  @$pb.TagNumber(6)
  $core.bool hasSourceUpdateTime() => $_has(5);
  @$pb.TagNumber(6)
  void clearSourceUpdateTime() => clearField(6);
  @$pb.TagNumber(6)
  $1.Timestamp ensureSourceUpdateTime() => $_ensure(5);

  /// CVSS version used to populate cvss_score and severity.
  @$pb.TagNumber(7)
  $0.CVSSVersion get cvssVersion => $_getN(6);
  @$pb.TagNumber(7)
  set cvssVersion($0.CVSSVersion v) {
    setField(7, v);
  }

  @$pb.TagNumber(7)
  $core.bool hasCvssVersion() => $_has(6);
  @$pb.TagNumber(7)
  void clearCvssVersion() => clearField(7);

  /// The full description of the v2 CVSS for this vulnerability.
  @$pb.TagNumber(8)
  $0.CVSS get cvssV2 => $_getN(7);
  @$pb.TagNumber(8)
  set cvssV2($0.CVSS v) {
    setField(8, v);
  }

  @$pb.TagNumber(8)
  $core.bool hasCvssV2() => $_has(7);
  @$pb.TagNumber(8)
  void clearCvssV2() => clearField(8);
  @$pb.TagNumber(8)
  $0.CVSS ensureCvssV2() => $_ensure(7);
}

/// A detail for a distro and package this vulnerability occurrence was found in
/// and its associated fix (if one is available).
class VulnerabilityOccurrence_PackageIssue extends $pb.GeneratedMessage {
  factory VulnerabilityOccurrence_PackageIssue({
    $core.String? affectedCpeUri,
    $core.String? affectedPackage,
    $2.Version? affectedVersion,
    $core.String? fixedCpeUri,
    $core.String? fixedPackage,
    $2.Version? fixedVersion,
    $core.bool? fixAvailable,
    $core.String? packageType,
    $5.Severity? effectiveSeverity,
    $core.Iterable<$3.FileLocation>? fileLocation,
  }) {
    final $result = create();
    if (affectedCpeUri != null) {
      $result.affectedCpeUri = affectedCpeUri;
    }
    if (affectedPackage != null) {
      $result.affectedPackage = affectedPackage;
    }
    if (affectedVersion != null) {
      $result.affectedVersion = affectedVersion;
    }
    if (fixedCpeUri != null) {
      $result.fixedCpeUri = fixedCpeUri;
    }
    if (fixedPackage != null) {
      $result.fixedPackage = fixedPackage;
    }
    if (fixedVersion != null) {
      $result.fixedVersion = fixedVersion;
    }
    if (fixAvailable != null) {
      $result.fixAvailable = fixAvailable;
    }
    if (packageType != null) {
      $result.packageType = packageType;
    }
    if (effectiveSeverity != null) {
      $result.effectiveSeverity = effectiveSeverity;
    }
    if (fileLocation != null) {
      $result.fileLocation.addAll(fileLocation);
    }
    return $result;
  }
  VulnerabilityOccurrence_PackageIssue._() : super();
  factory VulnerabilityOccurrence_PackageIssue.fromBuffer(
          $core.List<$core.int> i,
          [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) =>
      create()..mergeFromBuffer(i, r);
  factory VulnerabilityOccurrence_PackageIssue.fromJson($core.String i,
          [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) =>
      create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(
      _omitMessageNames ? '' : 'VulnerabilityOccurrence.PackageIssue',
      package: const $pb.PackageName(_omitMessageNames ? '' : 'grafeas.v1'),
      createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'affectedCpeUri')
    ..aOS(2, _omitFieldNames ? '' : 'affectedPackage')
    ..aOM<$2.Version>(3, _omitFieldNames ? '' : 'affectedVersion',
        subBuilder: $2.Version.create)
    ..aOS(4, _omitFieldNames ? '' : 'fixedCpeUri')
    ..aOS(5, _omitFieldNames ? '' : 'fixedPackage')
    ..aOM<$2.Version>(6, _omitFieldNames ? '' : 'fixedVersion',
        subBuilder: $2.Version.create)
    ..aOB(7, _omitFieldNames ? '' : 'fixAvailable')
    ..aOS(8, _omitFieldNames ? '' : 'packageType')
    ..e<$5.Severity>(
        9, _omitFieldNames ? '' : 'effectiveSeverity', $pb.PbFieldType.OE,
        defaultOrMaker: $5.Severity.SEVERITY_UNSPECIFIED,
        valueOf: $5.Severity.valueOf,
        enumValues: $5.Severity.values)
    ..pc<$3.FileLocation>(
        10, _omitFieldNames ? '' : 'fileLocation', $pb.PbFieldType.PM,
        subBuilder: $3.FileLocation.create)
    ..hasRequiredFields = false;

  @$core.Deprecated('Using this can add significant overhead to your binary. '
      'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
      'Will be removed in next major version')
  VulnerabilityOccurrence_PackageIssue clone() =>
      VulnerabilityOccurrence_PackageIssue()..mergeFromMessage(this);
  @$core.Deprecated('Using this can add significant overhead to your binary. '
      'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
      'Will be removed in next major version')
  VulnerabilityOccurrence_PackageIssue copyWith(
          void Function(VulnerabilityOccurrence_PackageIssue) updates) =>
      super.copyWith((message) =>
              updates(message as VulnerabilityOccurrence_PackageIssue))
          as VulnerabilityOccurrence_PackageIssue;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static VulnerabilityOccurrence_PackageIssue create() =>
      VulnerabilityOccurrence_PackageIssue._();
  VulnerabilityOccurrence_PackageIssue createEmptyInstance() => create();
  static $pb.PbList<VulnerabilityOccurrence_PackageIssue> createRepeated() =>
      $pb.PbList<VulnerabilityOccurrence_PackageIssue>();
  @$core.pragma('dart2js:noInline')
  static VulnerabilityOccurrence_PackageIssue getDefault() =>
      _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<
          VulnerabilityOccurrence_PackageIssue>(create);
  static VulnerabilityOccurrence_PackageIssue? _defaultInstance;

  /// Required. The [CPE URI](https://cpe.mitre.org/specification/) this
  /// vulnerability was found in.
  @$pb.TagNumber(1)
  $core.String get affectedCpeUri => $_getSZ(0);
  @$pb.TagNumber(1)
  set affectedCpeUri($core.String v) {
    $_setString(0, v);
  }

  @$pb.TagNumber(1)
  $core.bool hasAffectedCpeUri() => $_has(0);
  @$pb.TagNumber(1)
  void clearAffectedCpeUri() => clearField(1);

  /// Required. The package this vulnerability was found in.
  @$pb.TagNumber(2)
  $core.String get affectedPackage => $_getSZ(1);
  @$pb.TagNumber(2)
  set affectedPackage($core.String v) {
    $_setString(1, v);
  }

  @$pb.TagNumber(2)
  $core.bool hasAffectedPackage() => $_has(1);
  @$pb.TagNumber(2)
  void clearAffectedPackage() => clearField(2);

  /// Required. The version of the package that is installed on the resource
  /// affected by this vulnerability.
  @$pb.TagNumber(3)
  $2.Version get affectedVersion => $_getN(2);
  @$pb.TagNumber(3)
  set affectedVersion($2.Version v) {
    setField(3, v);
  }

  @$pb.TagNumber(3)
  $core.bool hasAffectedVersion() => $_has(2);
  @$pb.TagNumber(3)
  void clearAffectedVersion() => clearField(3);
  @$pb.TagNumber(3)
  $2.Version ensureAffectedVersion() => $_ensure(2);

  /// The [CPE URI](https://cpe.mitre.org/specification/) this vulnerability was
  /// fixed in. It is possible for this to be different from
  /// the affected_cpe_uri.
  @$pb.TagNumber(4)
  $core.String get fixedCpeUri => $_getSZ(3);
  @$pb.TagNumber(4)
  set fixedCpeUri($core.String v) {
    $_setString(3, v);
  }

  @$pb.TagNumber(4)
  $core.bool hasFixedCpeUri() => $_has(3);
  @$pb.TagNumber(4)
  void clearFixedCpeUri() => clearField(4);

  /// The package this vulnerability was fixed in. It is possible for this to be
  /// different from the affected_package.
  @$pb.TagNumber(5)
  $core.String get fixedPackage => $_getSZ(4);
  @$pb.TagNumber(5)
  set fixedPackage($core.String v) {
    $_setString(4, v);
  }

  @$pb.TagNumber(5)
  $core.bool hasFixedPackage() => $_has(4);
  @$pb.TagNumber(5)
  void clearFixedPackage() => clearField(5);

  /// Required. The version of the package this vulnerability was fixed in.
  /// Setting this to VersionKind.MAXIMUM means no fix is yet available.
  @$pb.TagNumber(6)
  $2.Version get fixedVersion => $_getN(5);
  @$pb.TagNumber(6)
  set fixedVersion($2.Version v) {
    setField(6, v);
  }

  @$pb.TagNumber(6)
  $core.bool hasFixedVersion() => $_has(5);
  @$pb.TagNumber(6)
  void clearFixedVersion() => clearField(6);
  @$pb.TagNumber(6)
  $2.Version ensureFixedVersion() => $_ensure(5);

  /// Output only. Whether a fix is available for this package.
  @$pb.TagNumber(7)
  $core.bool get fixAvailable => $_getBF(6);
  @$pb.TagNumber(7)
  set fixAvailable($core.bool v) {
    $_setBool(6, v);
  }

  @$pb.TagNumber(7)
  $core.bool hasFixAvailable() => $_has(6);
  @$pb.TagNumber(7)
  void clearFixAvailable() => clearField(7);

  /// The type of package (e.g. OS, MAVEN, GO).
  @$pb.TagNumber(8)
  $core.String get packageType => $_getSZ(7);
  @$pb.TagNumber(8)
  set packageType($core.String v) {
    $_setString(7, v);
  }

  @$pb.TagNumber(8)
  $core.bool hasPackageType() => $_has(7);
  @$pb.TagNumber(8)
  void clearPackageType() => clearField(8);

  /// The distro or language system assigned severity for this vulnerability
  /// when that is available and note provider assigned severity when it is not
  /// available.
  @$pb.TagNumber(9)
  $5.Severity get effectiveSeverity => $_getN(8);
  @$pb.TagNumber(9)
  set effectiveSeverity($5.Severity v) {
    setField(9, v);
  }

  @$pb.TagNumber(9)
  $core.bool hasEffectiveSeverity() => $_has(8);
  @$pb.TagNumber(9)
  void clearEffectiveSeverity() => clearField(9);

  /// The location at which this package was found.
  @$pb.TagNumber(10)
  $core.List<$3.FileLocation> get fileLocation => $_getList(9);
}

/// VexAssessment provides all publisher provided Vex information that is
/// related to this vulnerability.
class VulnerabilityOccurrence_VexAssessment extends $pb.GeneratedMessage {
  factory VulnerabilityOccurrence_VexAssessment({
    @$core.Deprecated('This field is deprecated.') $core.String? cve,
    $core.Iterable<$3.RelatedUrl>? relatedUris,
    $core.String? noteName,
    $4.VulnerabilityAssessmentNote_Assessment_State? state,
    $core.Iterable<$core.String>? impacts,
    $core.Iterable<$4.VulnerabilityAssessmentNote_Assessment_Remediation>?
        remediations,
    $4.VulnerabilityAssessmentNote_Assessment_Justification? justification,
    $core.String? vulnerabilityId,
  }) {
    final $result = create();
    if (cve != null) {
      // ignore: deprecated_member_use_from_same_package
      $result.cve = cve;
    }
    if (relatedUris != null) {
      $result.relatedUris.addAll(relatedUris);
    }
    if (noteName != null) {
      $result.noteName = noteName;
    }
    if (state != null) {
      $result.state = state;
    }
    if (impacts != null) {
      $result.impacts.addAll(impacts);
    }
    if (remediations != null) {
      $result.remediations.addAll(remediations);
    }
    if (justification != null) {
      $result.justification = justification;
    }
    if (vulnerabilityId != null) {
      $result.vulnerabilityId = vulnerabilityId;
    }
    return $result;
  }
  VulnerabilityOccurrence_VexAssessment._() : super();
  factory VulnerabilityOccurrence_VexAssessment.fromBuffer(
          $core.List<$core.int> i,
          [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) =>
      create()..mergeFromBuffer(i, r);
  factory VulnerabilityOccurrence_VexAssessment.fromJson($core.String i,
          [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) =>
      create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(
      _omitMessageNames ? '' : 'VulnerabilityOccurrence.VexAssessment',
      package: const $pb.PackageName(_omitMessageNames ? '' : 'grafeas.v1'),
      createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'cve')
    ..pc<$3.RelatedUrl>(
        2, _omitFieldNames ? '' : 'relatedUris', $pb.PbFieldType.PM,
        subBuilder: $3.RelatedUrl.create)
    ..aOS(3, _omitFieldNames ? '' : 'noteName')
    ..e<$4.VulnerabilityAssessmentNote_Assessment_State>(
        4, _omitFieldNames ? '' : 'state', $pb.PbFieldType.OE,
        defaultOrMaker:
            $4.VulnerabilityAssessmentNote_Assessment_State.STATE_UNSPECIFIED,
        valueOf: $4.VulnerabilityAssessmentNote_Assessment_State.valueOf,
        enumValues: $4.VulnerabilityAssessmentNote_Assessment_State.values)
    ..pPS(5, _omitFieldNames ? '' : 'impacts')
    ..pc<$4.VulnerabilityAssessmentNote_Assessment_Remediation>(
        6, _omitFieldNames ? '' : 'remediations', $pb.PbFieldType.PM,
        subBuilder:
            $4.VulnerabilityAssessmentNote_Assessment_Remediation.create)
    ..aOM<$4.VulnerabilityAssessmentNote_Assessment_Justification>(
        7, _omitFieldNames ? '' : 'justification',
        subBuilder:
            $4.VulnerabilityAssessmentNote_Assessment_Justification.create)
    ..aOS(8, _omitFieldNames ? '' : 'vulnerabilityId')
    ..hasRequiredFields = false;

  @$core.Deprecated('Using this can add significant overhead to your binary. '
      'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
      'Will be removed in next major version')
  VulnerabilityOccurrence_VexAssessment clone() =>
      VulnerabilityOccurrence_VexAssessment()..mergeFromMessage(this);
  @$core.Deprecated('Using this can add significant overhead to your binary. '
      'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
      'Will be removed in next major version')
  VulnerabilityOccurrence_VexAssessment copyWith(
          void Function(VulnerabilityOccurrence_VexAssessment) updates) =>
      super.copyWith((message) =>
              updates(message as VulnerabilityOccurrence_VexAssessment))
          as VulnerabilityOccurrence_VexAssessment;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static VulnerabilityOccurrence_VexAssessment create() =>
      VulnerabilityOccurrence_VexAssessment._();
  VulnerabilityOccurrence_VexAssessment createEmptyInstance() => create();
  static $pb.PbList<VulnerabilityOccurrence_VexAssessment> createRepeated() =>
      $pb.PbList<VulnerabilityOccurrence_VexAssessment>();
  @$core.pragma('dart2js:noInline')
  static VulnerabilityOccurrence_VexAssessment getDefault() =>
      _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<
          VulnerabilityOccurrence_VexAssessment>(create);
  static VulnerabilityOccurrence_VexAssessment? _defaultInstance;

  /// Holds the MITRE standard Common Vulnerabilities and Exposures (CVE)
  /// tracking number for the vulnerability.
  /// Deprecated: Use vulnerability_id instead to denote CVEs.
  @$core.Deprecated('This field is deprecated.')
  @$pb.TagNumber(1)
  $core.String get cve => $_getSZ(0);
  @$core.Deprecated('This field is deprecated.')
  @$pb.TagNumber(1)
  set cve($core.String v) {
    $_setString(0, v);
  }

  @$core.Deprecated('This field is deprecated.')
  @$pb.TagNumber(1)
  $core.bool hasCve() => $_has(0);
  @$core.Deprecated('This field is deprecated.')
  @$pb.TagNumber(1)
  void clearCve() => clearField(1);

  /// Holds a list of references associated with this vulnerability item and
  /// assessment.
  @$pb.TagNumber(2)
  $core.List<$3.RelatedUrl> get relatedUris => $_getList(1);

  /// The VulnerabilityAssessment note from which this VexAssessment was
  /// generated.
  /// This will be of the form: `projects/[PROJECT_ID]/notes/[NOTE_ID]`.
  /// (-- api-linter: core::0122::name-suffix=disabled
  ///     aip.dev/not-precedent: The suffix is kept for consistency. --)
  @$pb.TagNumber(3)
  $core.String get noteName => $_getSZ(2);
  @$pb.TagNumber(3)
  set noteName($core.String v) {
    $_setString(2, v);
  }

  @$pb.TagNumber(3)
  $core.bool hasNoteName() => $_has(2);
  @$pb.TagNumber(3)
  void clearNoteName() => clearField(3);

  /// Provides the state of this Vulnerability assessment.
  @$pb.TagNumber(4)
  $4.VulnerabilityAssessmentNote_Assessment_State get state => $_getN(3);
  @$pb.TagNumber(4)
  set state($4.VulnerabilityAssessmentNote_Assessment_State v) {
    setField(4, v);
  }

  @$pb.TagNumber(4)
  $core.bool hasState() => $_has(3);
  @$pb.TagNumber(4)
  void clearState() => clearField(4);

  /// Contains information about the impact of this vulnerability,
  /// this will change with time.
  @$pb.TagNumber(5)
  $core.List<$core.String> get impacts => $_getList(4);

  /// Specifies details on how to handle (and presumably, fix) a vulnerability.
  @$pb.TagNumber(6)
  $core.List<$4.VulnerabilityAssessmentNote_Assessment_Remediation>
      get remediations => $_getList(5);

  /// Justification provides the justification when the state of the
  /// assessment if NOT_AFFECTED.
  @$pb.TagNumber(7)
  $4.VulnerabilityAssessmentNote_Assessment_Justification get justification =>
      $_getN(6);
  @$pb.TagNumber(7)
  set justification($4.VulnerabilityAssessmentNote_Assessment_Justification v) {
    setField(7, v);
  }

  @$pb.TagNumber(7)
  $core.bool hasJustification() => $_has(6);
  @$pb.TagNumber(7)
  void clearJustification() => clearField(7);
  @$pb.TagNumber(7)
  $4.VulnerabilityAssessmentNote_Assessment_Justification
      ensureJustification() => $_ensure(6);

  /// The vulnerability identifier for this Assessment. Will hold one of
  /// common identifiers e.g. CVE, GHSA etc.
  @$pb.TagNumber(8)
  $core.String get vulnerabilityId => $_getSZ(7);
  @$pb.TagNumber(8)
  set vulnerabilityId($core.String v) {
    $_setString(7, v);
  }

  @$pb.TagNumber(8)
  $core.bool hasVulnerabilityId() => $_has(7);
  @$pb.TagNumber(8)
  void clearVulnerabilityId() => clearField(8);
}

/// An occurrence of a severity vulnerability on a resource.
class VulnerabilityOccurrence extends $pb.GeneratedMessage {
  factory VulnerabilityOccurrence({
    $core.String? type,
    $5.Severity? severity,
    $core.double? cvssScore,
    $core.Iterable<VulnerabilityOccurrence_PackageIssue>? packageIssue,
    $core.String? shortDescription,
    $core.String? longDescription,
    $core.Iterable<$3.RelatedUrl>? relatedUrls,
    $5.Severity? effectiveSeverity,
    $core.bool? fixAvailable,
    $0.CVSS? cvssv3,
    $0.CVSSVersion? cvssVersion,
    $0.CVSS? cvssV2,
    VulnerabilityOccurrence_VexAssessment? vexAssessment,
    $core.String? extraDetails,
  }) {
    final $result = create();
    if (type != null) {
      $result.type = type;
    }
    if (severity != null) {
      $result.severity = severity;
    }
    if (cvssScore != null) {
      $result.cvssScore = cvssScore;
    }
    if (packageIssue != null) {
      $result.packageIssue.addAll(packageIssue);
    }
    if (shortDescription != null) {
      $result.shortDescription = shortDescription;
    }
    if (longDescription != null) {
      $result.longDescription = longDescription;
    }
    if (relatedUrls != null) {
      $result.relatedUrls.addAll(relatedUrls);
    }
    if (effectiveSeverity != null) {
      $result.effectiveSeverity = effectiveSeverity;
    }
    if (fixAvailable != null) {
      $result.fixAvailable = fixAvailable;
    }
    if (cvssv3 != null) {
      $result.cvssv3 = cvssv3;
    }
    if (cvssVersion != null) {
      $result.cvssVersion = cvssVersion;
    }
    if (cvssV2 != null) {
      $result.cvssV2 = cvssV2;
    }
    if (vexAssessment != null) {
      $result.vexAssessment = vexAssessment;
    }
    if (extraDetails != null) {
      $result.extraDetails = extraDetails;
    }
    return $result;
  }
  VulnerabilityOccurrence._() : super();
  factory VulnerabilityOccurrence.fromBuffer($core.List<$core.int> i,
          [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) =>
      create()..mergeFromBuffer(i, r);
  factory VulnerabilityOccurrence.fromJson($core.String i,
          [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) =>
      create()..mergeFromJson(i, r);

  static final $pb.BuilderInfo _i = $pb.BuilderInfo(
      _omitMessageNames ? '' : 'VulnerabilityOccurrence',
      package: const $pb.PackageName(_omitMessageNames ? '' : 'grafeas.v1'),
      createEmptyInstance: create)
    ..aOS(1, _omitFieldNames ? '' : 'type')
    ..e<$5.Severity>(2, _omitFieldNames ? '' : 'severity', $pb.PbFieldType.OE,
        defaultOrMaker: $5.Severity.SEVERITY_UNSPECIFIED,
        valueOf: $5.Severity.valueOf,
        enumValues: $5.Severity.values)
    ..a<$core.double>(3, _omitFieldNames ? '' : 'cvssScore', $pb.PbFieldType.OF)
    ..pc<VulnerabilityOccurrence_PackageIssue>(
        4, _omitFieldNames ? '' : 'packageIssue', $pb.PbFieldType.PM,
        subBuilder: VulnerabilityOccurrence_PackageIssue.create)
    ..aOS(5, _omitFieldNames ? '' : 'shortDescription')
    ..aOS(6, _omitFieldNames ? '' : 'longDescription')
    ..pc<$3.RelatedUrl>(
        7, _omitFieldNames ? '' : 'relatedUrls', $pb.PbFieldType.PM,
        subBuilder: $3.RelatedUrl.create)
    ..e<$5.Severity>(
        8, _omitFieldNames ? '' : 'effectiveSeverity', $pb.PbFieldType.OE,
        defaultOrMaker: $5.Severity.SEVERITY_UNSPECIFIED,
        valueOf: $5.Severity.valueOf,
        enumValues: $5.Severity.values)
    ..aOB(9, _omitFieldNames ? '' : 'fixAvailable')
    ..aOM<$0.CVSS>(10, _omitFieldNames ? '' : 'cvssv3',
        subBuilder: $0.CVSS.create)
    ..e<$0.CVSSVersion>(
        11, _omitFieldNames ? '' : 'cvssVersion', $pb.PbFieldType.OE,
        defaultOrMaker: $0.CVSSVersion.CVSS_VERSION_UNSPECIFIED,
        valueOf: $0.CVSSVersion.valueOf,
        enumValues: $0.CVSSVersion.values)
    ..aOM<$0.CVSS>(12, _omitFieldNames ? '' : 'cvssV2',
        subBuilder: $0.CVSS.create)
    ..aOM<VulnerabilityOccurrence_VexAssessment>(
        13, _omitFieldNames ? '' : 'vexAssessment',
        subBuilder: VulnerabilityOccurrence_VexAssessment.create)
    ..aOS(14, _omitFieldNames ? '' : 'extraDetails')
    ..hasRequiredFields = false;

  @$core.Deprecated('Using this can add significant overhead to your binary. '
      'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
      'Will be removed in next major version')
  VulnerabilityOccurrence clone() =>
      VulnerabilityOccurrence()..mergeFromMessage(this);
  @$core.Deprecated('Using this can add significant overhead to your binary. '
      'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
      'Will be removed in next major version')
  VulnerabilityOccurrence copyWith(
          void Function(VulnerabilityOccurrence) updates) =>
      super.copyWith((message) => updates(message as VulnerabilityOccurrence))
          as VulnerabilityOccurrence;

  $pb.BuilderInfo get info_ => _i;

  @$core.pragma('dart2js:noInline')
  static VulnerabilityOccurrence create() => VulnerabilityOccurrence._();
  VulnerabilityOccurrence createEmptyInstance() => create();
  static $pb.PbList<VulnerabilityOccurrence> createRepeated() =>
      $pb.PbList<VulnerabilityOccurrence>();
  @$core.pragma('dart2js:noInline')
  static VulnerabilityOccurrence getDefault() => _defaultInstance ??=
      $pb.GeneratedMessage.$_defaultFor<VulnerabilityOccurrence>(create);
  static VulnerabilityOccurrence? _defaultInstance;

  /// The type of package; whether native or non native (e.g., ruby gems, node.js
  /// packages, etc.).
  @$pb.TagNumber(1)
  $core.String get type => $_getSZ(0);
  @$pb.TagNumber(1)
  set type($core.String v) {
    $_setString(0, v);
  }

  @$pb.TagNumber(1)
  $core.bool hasType() => $_has(0);
  @$pb.TagNumber(1)
  void clearType() => clearField(1);

  /// Output only. The note provider assigned severity of this vulnerability.
  @$pb.TagNumber(2)
  $5.Severity get severity => $_getN(1);
  @$pb.TagNumber(2)
  set severity($5.Severity v) {
    setField(2, v);
  }

  @$pb.TagNumber(2)
  $core.bool hasSeverity() => $_has(1);
  @$pb.TagNumber(2)
  void clearSeverity() => clearField(2);

  /// Output only. The CVSS score of this vulnerability. CVSS score is on a
  /// scale of 0 - 10 where 0 indicates low severity and 10 indicates high
  /// severity.
  @$pb.TagNumber(3)
  $core.double get cvssScore => $_getN(2);
  @$pb.TagNumber(3)
  set cvssScore($core.double v) {
    $_setFloat(2, v);
  }

  @$pb.TagNumber(3)
  $core.bool hasCvssScore() => $_has(2);
  @$pb.TagNumber(3)
  void clearCvssScore() => clearField(3);

  /// Required. The set of affected locations and their fixes (if available)
  /// within the associated resource.
  @$pb.TagNumber(4)
  $core.List<VulnerabilityOccurrence_PackageIssue> get packageIssue =>
      $_getList(3);

  /// Output only. A one sentence description of this vulnerability.
  @$pb.TagNumber(5)
  $core.String get shortDescription => $_getSZ(4);
  @$pb.TagNumber(5)
  set shortDescription($core.String v) {
    $_setString(4, v);
  }

  @$pb.TagNumber(5)
  $core.bool hasShortDescription() => $_has(4);
  @$pb.TagNumber(5)
  void clearShortDescription() => clearField(5);

  /// Output only. A detailed description of this vulnerability.
  @$pb.TagNumber(6)
  $core.String get longDescription => $_getSZ(5);
  @$pb.TagNumber(6)
  set longDescription($core.String v) {
    $_setString(5, v);
  }

  @$pb.TagNumber(6)
  $core.bool hasLongDescription() => $_has(5);
  @$pb.TagNumber(6)
  void clearLongDescription() => clearField(6);

  /// Output only. URLs related to this vulnerability.
  @$pb.TagNumber(7)
  $core.List<$3.RelatedUrl> get relatedUrls => $_getList(6);

  ///  The distro assigned severity for this vulnerability when it is available,
  ///  otherwise this is the note provider assigned severity.
  ///
  ///  When there are multiple PackageIssues for this vulnerability, they can have
  ///  different effective severities because some might be provided by the distro
  ///  while others are provided by the language ecosystem for a language pack.
  ///  For this reason, it is advised to use the effective severity on the
  ///  PackageIssue level. In the case where multiple PackageIssues have differing
  ///  effective severities, this field should be the highest severity for any of
  ///  the PackageIssues.
  @$pb.TagNumber(8)
  $5.Severity get effectiveSeverity => $_getN(7);
  @$pb.TagNumber(8)
  set effectiveSeverity($5.Severity v) {
    setField(8, v);
  }

  @$pb.TagNumber(8)
  $core.bool hasEffectiveSeverity() => $_has(7);
  @$pb.TagNumber(8)
  void clearEffectiveSeverity() => clearField(8);

  /// Output only. Whether at least one of the affected packages has a fix
  /// available.
  @$pb.TagNumber(9)
  $core.bool get fixAvailable => $_getBF(8);
  @$pb.TagNumber(9)
  set fixAvailable($core.bool v) {
    $_setBool(8, v);
  }

  @$pb.TagNumber(9)
  $core.bool hasFixAvailable() => $_has(8);
  @$pb.TagNumber(9)
  void clearFixAvailable() => clearField(9);

  /// The cvss v3 score for the vulnerability.
  @$pb.TagNumber(10)
  $0.CVSS get cvssv3 => $_getN(9);
  @$pb.TagNumber(10)
  set cvssv3($0.CVSS v) {
    setField(10, v);
  }

  @$pb.TagNumber(10)
  $core.bool hasCvssv3() => $_has(9);
  @$pb.TagNumber(10)
  void clearCvssv3() => clearField(10);
  @$pb.TagNumber(10)
  $0.CVSS ensureCvssv3() => $_ensure(9);

  /// Output only. CVSS version used to populate cvss_score and severity.
  @$pb.TagNumber(11)
  $0.CVSSVersion get cvssVersion => $_getN(10);
  @$pb.TagNumber(11)
  set cvssVersion($0.CVSSVersion v) {
    setField(11, v);
  }

  @$pb.TagNumber(11)
  $core.bool hasCvssVersion() => $_has(10);
  @$pb.TagNumber(11)
  void clearCvssVersion() => clearField(11);

  /// The cvss v2 score for the vulnerability.
  @$pb.TagNumber(12)
  $0.CVSS get cvssV2 => $_getN(11);
  @$pb.TagNumber(12)
  set cvssV2($0.CVSS v) {
    setField(12, v);
  }

  @$pb.TagNumber(12)
  $core.bool hasCvssV2() => $_has(11);
  @$pb.TagNumber(12)
  void clearCvssV2() => clearField(12);
  @$pb.TagNumber(12)
  $0.CVSS ensureCvssV2() => $_ensure(11);

  @$pb.TagNumber(13)
  VulnerabilityOccurrence_VexAssessment get vexAssessment => $_getN(12);
  @$pb.TagNumber(13)
  set vexAssessment(VulnerabilityOccurrence_VexAssessment v) {
    setField(13, v);
  }

  @$pb.TagNumber(13)
  $core.bool hasVexAssessment() => $_has(12);
  @$pb.TagNumber(13)
  void clearVexAssessment() => clearField(13);
  @$pb.TagNumber(13)
  VulnerabilityOccurrence_VexAssessment ensureVexAssessment() => $_ensure(12);

  /// Occurrence-specific extra details about the vulnerability.
  @$pb.TagNumber(14)
  $core.String get extraDetails => $_getSZ(13);
  @$pb.TagNumber(14)
  set extraDetails($core.String v) {
    $_setString(13, v);
  }

  @$pb.TagNumber(14)
  $core.bool hasExtraDetails() => $_has(13);
  @$pb.TagNumber(14)
  void clearExtraDetails() => clearField(14);
}

const _omitFieldNames = $core.bool.fromEnvironment('protobuf.omit_field_names');
const _omitMessageNames =
    $core.bool.fromEnvironment('protobuf.omit_message_names');
